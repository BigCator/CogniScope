# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from radar_msgs/SystemStateNew.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import std_msgs.msg

class SystemStateNew(genpy.Message):
  _md5sum = "5cd1f98266d88da5518e239931fd3c7a"
  _type = "radar_msgs/SystemStateNew"
  _has_header = True  # flag to mark the presence of a Header object
  _full_text = """Header                      header  # Includes measurement timestamp and coordinate frame.
char[20]                    projectCodeNum #project number
uint16                      productYear #manufacture date: year since 2000
uint16                      productMonth #manufacture date: month
uint16                      productDay #manufacture date: day
char[20]                    porductCode
char[40]                    serialNum
char[40]                    rfHwCode
uint16                      rfHwVersion
char[40]                    dspHwCode
uint16                      dspHwVersion
char[20]                    calibrateCode
char[20]                    osVersion
char[20]                    swVersion
char[20]                    algoVersion
char[20]                    waveformVersion
uint16                      a72_0_loading
uint16                      a72_1_loading
uint32                      a72_0_freq
uint32                      a72_1_freq
uint32                      mcu_0_freq
uint32                      mcu_1_freq
uint32                      mcu_2_freq
uint32                      mcu_3_freq
uint32                      lp_mcu_0_freq
uint32                      lp_mcu_1_freq
uint32                      c7x_mma_freq
uint32                      c66x_0_freq
uint32                      c66x_1_freq
uint32                      c7x_1_freq
uint16                      rebootCnt
uint16                      memoryLoading
uint32                      junctionTemp
uint16                      lowPowerModeEnable
uint16                      errorCode
uint16                      blockageDetection
uint16                      radarMode
uint16                      udpSendEnPnt
uint16                      udpSendEnTrk
uint16                      udpSendEnRDMap
uint16                      udpSendEnCfar
uint16                      udpSendEnAdc
uint16                      udpSendEnFft1D
uint16                      udpSendEnFft2D
uint16                      udpSendEnDOA
uint16                      radarTxFreq
uint16                      frameTriggerDelay
uint16                      syncEnable
uint16                      syncRadarNum
uint16                      antiInterfaceEnable
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id
"""
  __slots__ = ['header','projectCodeNum','productYear','productMonth','productDay','porductCode','serialNum','rfHwCode','rfHwVersion','dspHwCode','dspHwVersion','calibrateCode','osVersion','swVersion','algoVersion','waveformVersion','a72_0_loading','a72_1_loading','a72_0_freq','a72_1_freq','mcu_0_freq','mcu_1_freq','mcu_2_freq','mcu_3_freq','lp_mcu_0_freq','lp_mcu_1_freq','c7x_mma_freq','c66x_0_freq','c66x_1_freq','c7x_1_freq','rebootCnt','memoryLoading','junctionTemp','lowPowerModeEnable','errorCode','blockageDetection','radarMode','udpSendEnPnt','udpSendEnTrk','udpSendEnRDMap','udpSendEnCfar','udpSendEnAdc','udpSendEnFft1D','udpSendEnFft2D','udpSendEnDOA','radarTxFreq','frameTriggerDelay','syncEnable','syncRadarNum','antiInterfaceEnable']
  _slot_types = ['std_msgs/Header','char[20]','uint16','uint16','uint16','char[20]','char[40]','char[40]','uint16','char[40]','uint16','char[20]','char[20]','char[20]','char[20]','char[20]','uint16','uint16','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint16','uint16','uint32','uint16','uint16','uint16','uint16','uint16','uint16','uint16','uint16','uint16','uint16','uint16','uint16','uint16','uint16','uint16','uint16','uint16']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,projectCodeNum,productYear,productMonth,productDay,porductCode,serialNum,rfHwCode,rfHwVersion,dspHwCode,dspHwVersion,calibrateCode,osVersion,swVersion,algoVersion,waveformVersion,a72_0_loading,a72_1_loading,a72_0_freq,a72_1_freq,mcu_0_freq,mcu_1_freq,mcu_2_freq,mcu_3_freq,lp_mcu_0_freq,lp_mcu_1_freq,c7x_mma_freq,c66x_0_freq,c66x_1_freq,c7x_1_freq,rebootCnt,memoryLoading,junctionTemp,lowPowerModeEnable,errorCode,blockageDetection,radarMode,udpSendEnPnt,udpSendEnTrk,udpSendEnRDMap,udpSendEnCfar,udpSendEnAdc,udpSendEnFft1D,udpSendEnFft2D,udpSendEnDOA,radarTxFreq,frameTriggerDelay,syncEnable,syncRadarNum,antiInterfaceEnable

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(SystemStateNew, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.projectCodeNum is None:
        self.projectCodeNum = b'\0'*20
      if self.productYear is None:
        self.productYear = 0
      if self.productMonth is None:
        self.productMonth = 0
      if self.productDay is None:
        self.productDay = 0
      if self.porductCode is None:
        self.porductCode = b'\0'*20
      if self.serialNum is None:
        self.serialNum = b'\0'*40
      if self.rfHwCode is None:
        self.rfHwCode = b'\0'*40
      if self.rfHwVersion is None:
        self.rfHwVersion = 0
      if self.dspHwCode is None:
        self.dspHwCode = b'\0'*40
      if self.dspHwVersion is None:
        self.dspHwVersion = 0
      if self.calibrateCode is None:
        self.calibrateCode = b'\0'*20
      if self.osVersion is None:
        self.osVersion = b'\0'*20
      if self.swVersion is None:
        self.swVersion = b'\0'*20
      if self.algoVersion is None:
        self.algoVersion = b'\0'*20
      if self.waveformVersion is None:
        self.waveformVersion = b'\0'*20
      if self.a72_0_loading is None:
        self.a72_0_loading = 0
      if self.a72_1_loading is None:
        self.a72_1_loading = 0
      if self.a72_0_freq is None:
        self.a72_0_freq = 0
      if self.a72_1_freq is None:
        self.a72_1_freq = 0
      if self.mcu_0_freq is None:
        self.mcu_0_freq = 0
      if self.mcu_1_freq is None:
        self.mcu_1_freq = 0
      if self.mcu_2_freq is None:
        self.mcu_2_freq = 0
      if self.mcu_3_freq is None:
        self.mcu_3_freq = 0
      if self.lp_mcu_0_freq is None:
        self.lp_mcu_0_freq = 0
      if self.lp_mcu_1_freq is None:
        self.lp_mcu_1_freq = 0
      if self.c7x_mma_freq is None:
        self.c7x_mma_freq = 0
      if self.c66x_0_freq is None:
        self.c66x_0_freq = 0
      if self.c66x_1_freq is None:
        self.c66x_1_freq = 0
      if self.c7x_1_freq is None:
        self.c7x_1_freq = 0
      if self.rebootCnt is None:
        self.rebootCnt = 0
      if self.memoryLoading is None:
        self.memoryLoading = 0
      if self.junctionTemp is None:
        self.junctionTemp = 0
      if self.lowPowerModeEnable is None:
        self.lowPowerModeEnable = 0
      if self.errorCode is None:
        self.errorCode = 0
      if self.blockageDetection is None:
        self.blockageDetection = 0
      if self.radarMode is None:
        self.radarMode = 0
      if self.udpSendEnPnt is None:
        self.udpSendEnPnt = 0
      if self.udpSendEnTrk is None:
        self.udpSendEnTrk = 0
      if self.udpSendEnRDMap is None:
        self.udpSendEnRDMap = 0
      if self.udpSendEnCfar is None:
        self.udpSendEnCfar = 0
      if self.udpSendEnAdc is None:
        self.udpSendEnAdc = 0
      if self.udpSendEnFft1D is None:
        self.udpSendEnFft1D = 0
      if self.udpSendEnFft2D is None:
        self.udpSendEnFft2D = 0
      if self.udpSendEnDOA is None:
        self.udpSendEnDOA = 0
      if self.radarTxFreq is None:
        self.radarTxFreq = 0
      if self.frameTriggerDelay is None:
        self.frameTriggerDelay = 0
      if self.syncEnable is None:
        self.syncEnable = 0
      if self.syncRadarNum is None:
        self.syncRadarNum = 0
      if self.antiInterfaceEnable is None:
        self.antiInterfaceEnable = 0
    else:
      self.header = std_msgs.msg.Header()
      self.projectCodeNum = b'\0'*20
      self.productYear = 0
      self.productMonth = 0
      self.productDay = 0
      self.porductCode = b'\0'*20
      self.serialNum = b'\0'*40
      self.rfHwCode = b'\0'*40
      self.rfHwVersion = 0
      self.dspHwCode = b'\0'*40
      self.dspHwVersion = 0
      self.calibrateCode = b'\0'*20
      self.osVersion = b'\0'*20
      self.swVersion = b'\0'*20
      self.algoVersion = b'\0'*20
      self.waveformVersion = b'\0'*20
      self.a72_0_loading = 0
      self.a72_1_loading = 0
      self.a72_0_freq = 0
      self.a72_1_freq = 0
      self.mcu_0_freq = 0
      self.mcu_1_freq = 0
      self.mcu_2_freq = 0
      self.mcu_3_freq = 0
      self.lp_mcu_0_freq = 0
      self.lp_mcu_1_freq = 0
      self.c7x_mma_freq = 0
      self.c66x_0_freq = 0
      self.c66x_1_freq = 0
      self.c7x_1_freq = 0
      self.rebootCnt = 0
      self.memoryLoading = 0
      self.junctionTemp = 0
      self.lowPowerModeEnable = 0
      self.errorCode = 0
      self.blockageDetection = 0
      self.radarMode = 0
      self.udpSendEnPnt = 0
      self.udpSendEnTrk = 0
      self.udpSendEnRDMap = 0
      self.udpSendEnCfar = 0
      self.udpSendEnAdc = 0
      self.udpSendEnFft1D = 0
      self.udpSendEnFft2D = 0
      self.udpSendEnDOA = 0
      self.radarTxFreq = 0
      self.frameTriggerDelay = 0
      self.syncEnable = 0
      self.syncRadarNum = 0
      self.antiInterfaceEnable = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.projectCodeNum
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_20B().pack(*_x))
      else:
        buff.write(_get_struct_20s().pack(_x))
      _x = self
      buff.write(_get_struct_3H().pack(_x.productYear, _x.productMonth, _x.productDay))
      _x = self.porductCode
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_20B().pack(*_x))
      else:
        buff.write(_get_struct_20s().pack(_x))
      _x = self.serialNum
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_40B().pack(*_x))
      else:
        buff.write(_get_struct_40s().pack(_x))
      _x = self.rfHwCode
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_40B().pack(*_x))
      else:
        buff.write(_get_struct_40s().pack(_x))
      _x = self.rfHwVersion
      buff.write(_get_struct_H().pack(_x))
      _x = self.dspHwCode
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_40B().pack(*_x))
      else:
        buff.write(_get_struct_40s().pack(_x))
      _x = self.dspHwVersion
      buff.write(_get_struct_H().pack(_x))
      _x = self.calibrateCode
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_20B().pack(*_x))
      else:
        buff.write(_get_struct_20s().pack(_x))
      _x = self.osVersion
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_20B().pack(*_x))
      else:
        buff.write(_get_struct_20s().pack(_x))
      _x = self.swVersion
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_20B().pack(*_x))
      else:
        buff.write(_get_struct_20s().pack(_x))
      _x = self.algoVersion
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_20B().pack(*_x))
      else:
        buff.write(_get_struct_20s().pack(_x))
      _x = self.waveformVersion
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_20B().pack(*_x))
      else:
        buff.write(_get_struct_20s().pack(_x))
      _x = self
      buff.write(_get_struct_2H12I2HI17H().pack(_x.a72_0_loading, _x.a72_1_loading, _x.a72_0_freq, _x.a72_1_freq, _x.mcu_0_freq, _x.mcu_1_freq, _x.mcu_2_freq, _x.mcu_3_freq, _x.lp_mcu_0_freq, _x.lp_mcu_1_freq, _x.c7x_mma_freq, _x.c66x_0_freq, _x.c66x_1_freq, _x.c7x_1_freq, _x.rebootCnt, _x.memoryLoading, _x.junctionTemp, _x.lowPowerModeEnable, _x.errorCode, _x.blockageDetection, _x.radarMode, _x.udpSendEnPnt, _x.udpSendEnTrk, _x.udpSendEnRDMap, _x.udpSendEnCfar, _x.udpSendEnAdc, _x.udpSendEnFft1D, _x.udpSendEnFft2D, _x.udpSendEnDOA, _x.radarTxFreq, _x.frameTriggerDelay, _x.syncEnable, _x.syncRadarNum, _x.antiInterfaceEnable))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      start = end
      end += 20
      self.projectCodeNum = str[start:end]
      _x = self
      start = end
      end += 6
      (_x.productYear, _x.productMonth, _x.productDay,) = _get_struct_3H().unpack(str[start:end])
      start = end
      end += 20
      self.porductCode = str[start:end]
      start = end
      end += 40
      self.serialNum = str[start:end]
      start = end
      end += 40
      self.rfHwCode = str[start:end]
      start = end
      end += 2
      (self.rfHwVersion,) = _get_struct_H().unpack(str[start:end])
      start = end
      end += 40
      self.dspHwCode = str[start:end]
      start = end
      end += 2
      (self.dspHwVersion,) = _get_struct_H().unpack(str[start:end])
      start = end
      end += 20
      self.calibrateCode = str[start:end]
      start = end
      end += 20
      self.osVersion = str[start:end]
      start = end
      end += 20
      self.swVersion = str[start:end]
      start = end
      end += 20
      self.algoVersion = str[start:end]
      start = end
      end += 20
      self.waveformVersion = str[start:end]
      _x = self
      start = end
      end += 94
      (_x.a72_0_loading, _x.a72_1_loading, _x.a72_0_freq, _x.a72_1_freq, _x.mcu_0_freq, _x.mcu_1_freq, _x.mcu_2_freq, _x.mcu_3_freq, _x.lp_mcu_0_freq, _x.lp_mcu_1_freq, _x.c7x_mma_freq, _x.c66x_0_freq, _x.c66x_1_freq, _x.c7x_1_freq, _x.rebootCnt, _x.memoryLoading, _x.junctionTemp, _x.lowPowerModeEnable, _x.errorCode, _x.blockageDetection, _x.radarMode, _x.udpSendEnPnt, _x.udpSendEnTrk, _x.udpSendEnRDMap, _x.udpSendEnCfar, _x.udpSendEnAdc, _x.udpSendEnFft1D, _x.udpSendEnFft2D, _x.udpSendEnDOA, _x.radarTxFreq, _x.frameTriggerDelay, _x.syncEnable, _x.syncRadarNum, _x.antiInterfaceEnable,) = _get_struct_2H12I2HI17H().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.projectCodeNum
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_20B().pack(*_x))
      else:
        buff.write(_get_struct_20s().pack(_x))
      _x = self
      buff.write(_get_struct_3H().pack(_x.productYear, _x.productMonth, _x.productDay))
      _x = self.porductCode
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_20B().pack(*_x))
      else:
        buff.write(_get_struct_20s().pack(_x))
      _x = self.serialNum
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_40B().pack(*_x))
      else:
        buff.write(_get_struct_40s().pack(_x))
      _x = self.rfHwCode
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_40B().pack(*_x))
      else:
        buff.write(_get_struct_40s().pack(_x))
      _x = self.rfHwVersion
      buff.write(_get_struct_H().pack(_x))
      _x = self.dspHwCode
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_40B().pack(*_x))
      else:
        buff.write(_get_struct_40s().pack(_x))
      _x = self.dspHwVersion
      buff.write(_get_struct_H().pack(_x))
      _x = self.calibrateCode
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_20B().pack(*_x))
      else:
        buff.write(_get_struct_20s().pack(_x))
      _x = self.osVersion
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_20B().pack(*_x))
      else:
        buff.write(_get_struct_20s().pack(_x))
      _x = self.swVersion
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_20B().pack(*_x))
      else:
        buff.write(_get_struct_20s().pack(_x))
      _x = self.algoVersion
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_20B().pack(*_x))
      else:
        buff.write(_get_struct_20s().pack(_x))
      _x = self.waveformVersion
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_20B().pack(*_x))
      else:
        buff.write(_get_struct_20s().pack(_x))
      _x = self
      buff.write(_get_struct_2H12I2HI17H().pack(_x.a72_0_loading, _x.a72_1_loading, _x.a72_0_freq, _x.a72_1_freq, _x.mcu_0_freq, _x.mcu_1_freq, _x.mcu_2_freq, _x.mcu_3_freq, _x.lp_mcu_0_freq, _x.lp_mcu_1_freq, _x.c7x_mma_freq, _x.c66x_0_freq, _x.c66x_1_freq, _x.c7x_1_freq, _x.rebootCnt, _x.memoryLoading, _x.junctionTemp, _x.lowPowerModeEnable, _x.errorCode, _x.blockageDetection, _x.radarMode, _x.udpSendEnPnt, _x.udpSendEnTrk, _x.udpSendEnRDMap, _x.udpSendEnCfar, _x.udpSendEnAdc, _x.udpSendEnFft1D, _x.udpSendEnFft2D, _x.udpSendEnDOA, _x.radarTxFreq, _x.frameTriggerDelay, _x.syncEnable, _x.syncRadarNum, _x.antiInterfaceEnable))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      start = end
      end += 20
      self.projectCodeNum = str[start:end]
      _x = self
      start = end
      end += 6
      (_x.productYear, _x.productMonth, _x.productDay,) = _get_struct_3H().unpack(str[start:end])
      start = end
      end += 20
      self.porductCode = str[start:end]
      start = end
      end += 40
      self.serialNum = str[start:end]
      start = end
      end += 40
      self.rfHwCode = str[start:end]
      start = end
      end += 2
      (self.rfHwVersion,) = _get_struct_H().unpack(str[start:end])
      start = end
      end += 40
      self.dspHwCode = str[start:end]
      start = end
      end += 2
      (self.dspHwVersion,) = _get_struct_H().unpack(str[start:end])
      start = end
      end += 20
      self.calibrateCode = str[start:end]
      start = end
      end += 20
      self.osVersion = str[start:end]
      start = end
      end += 20
      self.swVersion = str[start:end]
      start = end
      end += 20
      self.algoVersion = str[start:end]
      start = end
      end += 20
      self.waveformVersion = str[start:end]
      _x = self
      start = end
      end += 94
      (_x.a72_0_loading, _x.a72_1_loading, _x.a72_0_freq, _x.a72_1_freq, _x.mcu_0_freq, _x.mcu_1_freq, _x.mcu_2_freq, _x.mcu_3_freq, _x.lp_mcu_0_freq, _x.lp_mcu_1_freq, _x.c7x_mma_freq, _x.c66x_0_freq, _x.c66x_1_freq, _x.c7x_1_freq, _x.rebootCnt, _x.memoryLoading, _x.junctionTemp, _x.lowPowerModeEnable, _x.errorCode, _x.blockageDetection, _x.radarMode, _x.udpSendEnPnt, _x.udpSendEnTrk, _x.udpSendEnRDMap, _x.udpSendEnCfar, _x.udpSendEnAdc, _x.udpSendEnFft1D, _x.udpSendEnFft2D, _x.udpSendEnDOA, _x.radarTxFreq, _x.frameTriggerDelay, _x.syncEnable, _x.syncRadarNum, _x.antiInterfaceEnable,) = _get_struct_2H12I2HI17H().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_20B = None
def _get_struct_20B():
    global _struct_20B
    if _struct_20B is None:
        _struct_20B = struct.Struct("<20B")
    return _struct_20B
_struct_20s = None
def _get_struct_20s():
    global _struct_20s
    if _struct_20s is None:
        _struct_20s = struct.Struct("<20s")
    return _struct_20s
_struct_2H12I2HI17H = None
def _get_struct_2H12I2HI17H():
    global _struct_2H12I2HI17H
    if _struct_2H12I2HI17H is None:
        _struct_2H12I2HI17H = struct.Struct("<2H12I2HI17H")
    return _struct_2H12I2HI17H
_struct_3H = None
def _get_struct_3H():
    global _struct_3H
    if _struct_3H is None:
        _struct_3H = struct.Struct("<3H")
    return _struct_3H
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
_struct_40B = None
def _get_struct_40B():
    global _struct_40B
    if _struct_40B is None:
        _struct_40B = struct.Struct("<40B")
    return _struct_40B
_struct_40s = None
def _get_struct_40s():
    global _struct_40s
    if _struct_40s is None:
        _struct_40s = struct.Struct("<40s")
    return _struct_40s
_struct_H = None
def _get_struct_H():
    global _struct_H
    if _struct_H is None:
        _struct_H = struct.Struct("<H")
    return _struct_H
