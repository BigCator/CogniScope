// Generated by gencpp from file radar_msgs/ChassisMsg.msg
// DO NOT EDIT!


#ifndef RADAR_MSGS_MESSAGE_CHASSISMSG_H
#define RADAR_MSGS_MESSAGE_CHASSISMSG_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace radar_msgs
{
template <class ContainerAllocator>
struct ChassisMsg_
{
  typedef ChassisMsg_<ContainerAllocator> Type;

  ChassisMsg_()
    : header()
    , isLessInfo(false)
    , reserved(0)
    , VehDynYawRateHSC2(0.0)
    , VehDynYawRateVHSC2(0.0)
    , TrShftLvrPos_h1HSC2(0)
    , TrShftLvrPosV_h1HSC2(0)
    , VehSpdAvgDrvnHSC2(0.0)
    , VehSpdAvgDrvnVHSC2(0)
    , VehSpdAvgNonDrvnHSC2(0.0)
    , VehSpdAvgNonDrvnVHSC2(0)
    , StrgWhlAngHSC2(0.0)
    , StrgWhlAngVHSC2(0)
    , nCounter(0)
    , iTimeStamp(0)
    , fLatitude(0.0)
    , fLongitude(0.0)
    , fAltitude(0.0)
    , fAccX(0.0)
    , fAccY(0.0)
    , fAccZ(0.0)
    , fAngRateX(0.0)
    , fAngRateY(0.0)
    , fAngRateZ(0.0)
    , fVelNorth(0.0)
    , fVelWest(0.0)
    , fVelUp(0.0)
    , fHeading(0.0)
    , fPitch(0.0)
    , fRoll(0.0)
    , nNavStatus(0)
    , vTimeStamp(0)
    , fSteeringAngle(0.0)
    , fSpeed(0.0)
    , fYawRate(0.0)
    , fFrontLeftWheelSpeed(0.0)
    , fFrontRightWheelSpeed(0.0)
    , fRearLeftWheelSpeed(0.0)
    , fRearRightWheelSpeed(0.0)
    , nShifterPosition(0)
    , nLeftDirectionLamp(0)
    , nRightDirectionLamp(0)
    , nMainBeamLamp(0)
    , nDippedBeamLamp(0)
    , nWiperState(0)
    , fLateralAccel(0.0)
    , fLongituAccel(0.0)
    , nLeftDrivenWheelPulseCounters(0)
    , nRightDrivenWheelPulseCounters(0)
    , nLeftNonDrivenWheelPulseCounters(0)
    , nRightNonDrivenWheelPulseCounters(0)
    , nDriveMode(0)  {
    }
  ChassisMsg_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , isLessInfo(false)
    , reserved(0)
    , VehDynYawRateHSC2(0.0)
    , VehDynYawRateVHSC2(0.0)
    , TrShftLvrPos_h1HSC2(0)
    , TrShftLvrPosV_h1HSC2(0)
    , VehSpdAvgDrvnHSC2(0.0)
    , VehSpdAvgDrvnVHSC2(0)
    , VehSpdAvgNonDrvnHSC2(0.0)
    , VehSpdAvgNonDrvnVHSC2(0)
    , StrgWhlAngHSC2(0.0)
    , StrgWhlAngVHSC2(0)
    , nCounter(0)
    , iTimeStamp(0)
    , fLatitude(0.0)
    , fLongitude(0.0)
    , fAltitude(0.0)
    , fAccX(0.0)
    , fAccY(0.0)
    , fAccZ(0.0)
    , fAngRateX(0.0)
    , fAngRateY(0.0)
    , fAngRateZ(0.0)
    , fVelNorth(0.0)
    , fVelWest(0.0)
    , fVelUp(0.0)
    , fHeading(0.0)
    , fPitch(0.0)
    , fRoll(0.0)
    , nNavStatus(0)
    , vTimeStamp(0)
    , fSteeringAngle(0.0)
    , fSpeed(0.0)
    , fYawRate(0.0)
    , fFrontLeftWheelSpeed(0.0)
    , fFrontRightWheelSpeed(0.0)
    , fRearLeftWheelSpeed(0.0)
    , fRearRightWheelSpeed(0.0)
    , nShifterPosition(0)
    , nLeftDirectionLamp(0)
    , nRightDirectionLamp(0)
    , nMainBeamLamp(0)
    , nDippedBeamLamp(0)
    , nWiperState(0)
    , fLateralAccel(0.0)
    , fLongituAccel(0.0)
    , nLeftDrivenWheelPulseCounters(0)
    , nRightDrivenWheelPulseCounters(0)
    , nLeftNonDrivenWheelPulseCounters(0)
    , nRightNonDrivenWheelPulseCounters(0)
    , nDriveMode(0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef uint8_t _isLessInfo_type;
  _isLessInfo_type isLessInfo;

   typedef uint8_t _reserved_type;
  _reserved_type reserved;

   typedef float _VehDynYawRateHSC2_type;
  _VehDynYawRateHSC2_type VehDynYawRateHSC2;

   typedef float _VehDynYawRateVHSC2_type;
  _VehDynYawRateVHSC2_type VehDynYawRateVHSC2;

   typedef int32_t _TrShftLvrPos_h1HSC2_type;
  _TrShftLvrPos_h1HSC2_type TrShftLvrPos_h1HSC2;

   typedef int32_t _TrShftLvrPosV_h1HSC2_type;
  _TrShftLvrPosV_h1HSC2_type TrShftLvrPosV_h1HSC2;

   typedef float _VehSpdAvgDrvnHSC2_type;
  _VehSpdAvgDrvnHSC2_type VehSpdAvgDrvnHSC2;

   typedef int32_t _VehSpdAvgDrvnVHSC2_type;
  _VehSpdAvgDrvnVHSC2_type VehSpdAvgDrvnVHSC2;

   typedef float _VehSpdAvgNonDrvnHSC2_type;
  _VehSpdAvgNonDrvnHSC2_type VehSpdAvgNonDrvnHSC2;

   typedef int32_t _VehSpdAvgNonDrvnVHSC2_type;
  _VehSpdAvgNonDrvnVHSC2_type VehSpdAvgNonDrvnVHSC2;

   typedef float _StrgWhlAngHSC2_type;
  _StrgWhlAngHSC2_type StrgWhlAngHSC2;

   typedef int32_t _StrgWhlAngVHSC2_type;
  _StrgWhlAngVHSC2_type StrgWhlAngVHSC2;

   typedef int16_t _nCounter_type;
  _nCounter_type nCounter;

   typedef int64_t _iTimeStamp_type;
  _iTimeStamp_type iTimeStamp;

   typedef double _fLatitude_type;
  _fLatitude_type fLatitude;

   typedef double _fLongitude_type;
  _fLongitude_type fLongitude;

   typedef float _fAltitude_type;
  _fAltitude_type fAltitude;

   typedef float _fAccX_type;
  _fAccX_type fAccX;

   typedef float _fAccY_type;
  _fAccY_type fAccY;

   typedef float _fAccZ_type;
  _fAccZ_type fAccZ;

   typedef float _fAngRateX_type;
  _fAngRateX_type fAngRateX;

   typedef float _fAngRateY_type;
  _fAngRateY_type fAngRateY;

   typedef float _fAngRateZ_type;
  _fAngRateZ_type fAngRateZ;

   typedef float _fVelNorth_type;
  _fVelNorth_type fVelNorth;

   typedef float _fVelWest_type;
  _fVelWest_type fVelWest;

   typedef float _fVelUp_type;
  _fVelUp_type fVelUp;

   typedef float _fHeading_type;
  _fHeading_type fHeading;

   typedef float _fPitch_type;
  _fPitch_type fPitch;

   typedef float _fRoll_type;
  _fRoll_type fRoll;

   typedef int8_t _nNavStatus_type;
  _nNavStatus_type nNavStatus;

   typedef int64_t _vTimeStamp_type;
  _vTimeStamp_type vTimeStamp;

   typedef float _fSteeringAngle_type;
  _fSteeringAngle_type fSteeringAngle;

   typedef float _fSpeed_type;
  _fSpeed_type fSpeed;

   typedef float _fYawRate_type;
  _fYawRate_type fYawRate;

   typedef float _fFrontLeftWheelSpeed_type;
  _fFrontLeftWheelSpeed_type fFrontLeftWheelSpeed;

   typedef float _fFrontRightWheelSpeed_type;
  _fFrontRightWheelSpeed_type fFrontRightWheelSpeed;

   typedef float _fRearLeftWheelSpeed_type;
  _fRearLeftWheelSpeed_type fRearLeftWheelSpeed;

   typedef float _fRearRightWheelSpeed_type;
  _fRearRightWheelSpeed_type fRearRightWheelSpeed;

   typedef uint8_t _nShifterPosition_type;
  _nShifterPosition_type nShifterPosition;

   typedef uint8_t _nLeftDirectionLamp_type;
  _nLeftDirectionLamp_type nLeftDirectionLamp;

   typedef uint8_t _nRightDirectionLamp_type;
  _nRightDirectionLamp_type nRightDirectionLamp;

   typedef uint8_t _nMainBeamLamp_type;
  _nMainBeamLamp_type nMainBeamLamp;

   typedef uint8_t _nDippedBeamLamp_type;
  _nDippedBeamLamp_type nDippedBeamLamp;

   typedef uint8_t _nWiperState_type;
  _nWiperState_type nWiperState;

   typedef float _fLateralAccel_type;
  _fLateralAccel_type fLateralAccel;

   typedef float _fLongituAccel_type;
  _fLongituAccel_type fLongituAccel;

   typedef int16_t _nLeftDrivenWheelPulseCounters_type;
  _nLeftDrivenWheelPulseCounters_type nLeftDrivenWheelPulseCounters;

   typedef int16_t _nRightDrivenWheelPulseCounters_type;
  _nRightDrivenWheelPulseCounters_type nRightDrivenWheelPulseCounters;

   typedef int16_t _nLeftNonDrivenWheelPulseCounters_type;
  _nLeftNonDrivenWheelPulseCounters_type nLeftNonDrivenWheelPulseCounters;

   typedef int16_t _nRightNonDrivenWheelPulseCounters_type;
  _nRightNonDrivenWheelPulseCounters_type nRightNonDrivenWheelPulseCounters;

   typedef uint8_t _nDriveMode_type;
  _nDriveMode_type nDriveMode;





  typedef boost::shared_ptr< ::radar_msgs::ChassisMsg_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::radar_msgs::ChassisMsg_<ContainerAllocator> const> ConstPtr;

}; // struct ChassisMsg_

typedef ::radar_msgs::ChassisMsg_<std::allocator<void> > ChassisMsg;

typedef boost::shared_ptr< ::radar_msgs::ChassisMsg > ChassisMsgPtr;
typedef boost::shared_ptr< ::radar_msgs::ChassisMsg const> ChassisMsgConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::radar_msgs::ChassisMsg_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::radar_msgs::ChassisMsg_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::radar_msgs::ChassisMsg_<ContainerAllocator1> & lhs, const ::radar_msgs::ChassisMsg_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.isLessInfo == rhs.isLessInfo &&
    lhs.reserved == rhs.reserved &&
    lhs.VehDynYawRateHSC2 == rhs.VehDynYawRateHSC2 &&
    lhs.VehDynYawRateVHSC2 == rhs.VehDynYawRateVHSC2 &&
    lhs.TrShftLvrPos_h1HSC2 == rhs.TrShftLvrPos_h1HSC2 &&
    lhs.TrShftLvrPosV_h1HSC2 == rhs.TrShftLvrPosV_h1HSC2 &&
    lhs.VehSpdAvgDrvnHSC2 == rhs.VehSpdAvgDrvnHSC2 &&
    lhs.VehSpdAvgDrvnVHSC2 == rhs.VehSpdAvgDrvnVHSC2 &&
    lhs.VehSpdAvgNonDrvnHSC2 == rhs.VehSpdAvgNonDrvnHSC2 &&
    lhs.VehSpdAvgNonDrvnVHSC2 == rhs.VehSpdAvgNonDrvnVHSC2 &&
    lhs.StrgWhlAngHSC2 == rhs.StrgWhlAngHSC2 &&
    lhs.StrgWhlAngVHSC2 == rhs.StrgWhlAngVHSC2 &&
    lhs.nCounter == rhs.nCounter &&
    lhs.iTimeStamp == rhs.iTimeStamp &&
    lhs.fLatitude == rhs.fLatitude &&
    lhs.fLongitude == rhs.fLongitude &&
    lhs.fAltitude == rhs.fAltitude &&
    lhs.fAccX == rhs.fAccX &&
    lhs.fAccY == rhs.fAccY &&
    lhs.fAccZ == rhs.fAccZ &&
    lhs.fAngRateX == rhs.fAngRateX &&
    lhs.fAngRateY == rhs.fAngRateY &&
    lhs.fAngRateZ == rhs.fAngRateZ &&
    lhs.fVelNorth == rhs.fVelNorth &&
    lhs.fVelWest == rhs.fVelWest &&
    lhs.fVelUp == rhs.fVelUp &&
    lhs.fHeading == rhs.fHeading &&
    lhs.fPitch == rhs.fPitch &&
    lhs.fRoll == rhs.fRoll &&
    lhs.nNavStatus == rhs.nNavStatus &&
    lhs.vTimeStamp == rhs.vTimeStamp &&
    lhs.fSteeringAngle == rhs.fSteeringAngle &&
    lhs.fSpeed == rhs.fSpeed &&
    lhs.fYawRate == rhs.fYawRate &&
    lhs.fFrontLeftWheelSpeed == rhs.fFrontLeftWheelSpeed &&
    lhs.fFrontRightWheelSpeed == rhs.fFrontRightWheelSpeed &&
    lhs.fRearLeftWheelSpeed == rhs.fRearLeftWheelSpeed &&
    lhs.fRearRightWheelSpeed == rhs.fRearRightWheelSpeed &&
    lhs.nShifterPosition == rhs.nShifterPosition &&
    lhs.nLeftDirectionLamp == rhs.nLeftDirectionLamp &&
    lhs.nRightDirectionLamp == rhs.nRightDirectionLamp &&
    lhs.nMainBeamLamp == rhs.nMainBeamLamp &&
    lhs.nDippedBeamLamp == rhs.nDippedBeamLamp &&
    lhs.nWiperState == rhs.nWiperState &&
    lhs.fLateralAccel == rhs.fLateralAccel &&
    lhs.fLongituAccel == rhs.fLongituAccel &&
    lhs.nLeftDrivenWheelPulseCounters == rhs.nLeftDrivenWheelPulseCounters &&
    lhs.nRightDrivenWheelPulseCounters == rhs.nRightDrivenWheelPulseCounters &&
    lhs.nLeftNonDrivenWheelPulseCounters == rhs.nLeftNonDrivenWheelPulseCounters &&
    lhs.nRightNonDrivenWheelPulseCounters == rhs.nRightNonDrivenWheelPulseCounters &&
    lhs.nDriveMode == rhs.nDriveMode;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::radar_msgs::ChassisMsg_<ContainerAllocator1> & lhs, const ::radar_msgs::ChassisMsg_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace radar_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::radar_msgs::ChassisMsg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::radar_msgs::ChassisMsg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::radar_msgs::ChassisMsg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::radar_msgs::ChassisMsg_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::radar_msgs::ChassisMsg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::radar_msgs::ChassisMsg_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::radar_msgs::ChassisMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "178cdfa29e24c2bd952c01d011c7be7e";
  }

  static const char* value(const ::radar_msgs::ChassisMsg_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x178cdfa29e24c2bdULL;
  static const uint64_t static_value2 = 0x952c01d011c7be7eULL;
};

template<class ContainerAllocator>
struct DataType< ::radar_msgs::ChassisMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "radar_msgs/ChassisMsg";
  }

  static const char* value(const ::radar_msgs::ChassisMsg_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::radar_msgs::ChassisMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header           # packet header\n"
"bool isLessInfo\n"
"uint8 reserved\n"
"# lessInfo start\n"
"#yaw\n"
"float32 VehDynYawRateHSC2\n"
"float32 VehDynYawRateVHSC2\n"
"#shift\n"
"int32 TrShftLvrPos_h1HSC2\n"
"int32 TrShftLvrPosV_h1HSC2\n"
"#spped\n"
"float32 VehSpdAvgDrvnHSC2\n"
"int32 VehSpdAvgDrvnVHSC2\n"
"float32 VehSpdAvgNonDrvnHSC2\n"
"int32 VehSpdAvgNonDrvnVHSC2\n"
"#wheel\n"
"float32 StrgWhlAngHSC2\n"
"int32 StrgWhlAngVHSC2\n"
"# lessInfo end\n"
"\n"
"# more info start\n"
"int16 nCounter\n"
"# INERTIAL\n"
"int64 iTimeStamp\n"
"float64 fLatitude\n"
"float64 fLongitude\n"
"float32 fAltitude\n"
"float32 fAccX\n"
"float32 fAccY\n"
"float32 fAccZ\n"
"float32 fAngRateX\n"
"float32 fAngRateY\n"
"float32 fAngRateZ\n"
"float32 fVelNorth\n"
"float32 fVelWest\n"
"float32 fVelUp\n"
"float32 fHeading\n"
"float32 fPitch\n"
"float32 fRoll\n"
"int8 nNavStatus\n"
"#uint8 nWiperStatus\n"
"#float32 fDrnvelL\n"
"#float32 fNonDrnvelL\n"
"#float32 fDrnvelR\n"
"#float32 fNonDrnvelR\n"
"#float32 dTrailerAngle\n"
"\n"
"# VCU_VEHICLE_INFO\n"
"int64 vTimeStamp\n"
"#float32 fSteeringAngleVel\n"
"float32 fSteeringAngle\n"
"float32 fSpeed\n"
"float32 fYawRate\n"
"float32 fFrontLeftWheelSpeed\n"
"float32 fFrontRightWheelSpeed\n"
"float32 fRearLeftWheelSpeed\n"
"float32 fRearRightWheelSpeed\n"
"uint8 nShifterPosition\n"
"uint8 nLeftDirectionLamp\n"
"uint8 nRightDirectionLamp\n"
"uint8 nMainBeamLamp\n"
"uint8 nDippedBeamLamp\n"
"uint8 nWiperState\n"
"float32 fLateralAccel\n"
"float32 fLongituAccel\n"
"int16 nLeftDrivenWheelPulseCounters\n"
"int16 nRightDrivenWheelPulseCounters\n"
"int16 nLeftNonDrivenWheelPulseCounters\n"
"int16 nRightNonDrivenWheelPulseCounters\n"
"uint8 nDriveMode\n"
"\n"
"# more info end\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::radar_msgs::ChassisMsg_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::radar_msgs::ChassisMsg_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.isLessInfo);
      stream.next(m.reserved);
      stream.next(m.VehDynYawRateHSC2);
      stream.next(m.VehDynYawRateVHSC2);
      stream.next(m.TrShftLvrPos_h1HSC2);
      stream.next(m.TrShftLvrPosV_h1HSC2);
      stream.next(m.VehSpdAvgDrvnHSC2);
      stream.next(m.VehSpdAvgDrvnVHSC2);
      stream.next(m.VehSpdAvgNonDrvnHSC2);
      stream.next(m.VehSpdAvgNonDrvnVHSC2);
      stream.next(m.StrgWhlAngHSC2);
      stream.next(m.StrgWhlAngVHSC2);
      stream.next(m.nCounter);
      stream.next(m.iTimeStamp);
      stream.next(m.fLatitude);
      stream.next(m.fLongitude);
      stream.next(m.fAltitude);
      stream.next(m.fAccX);
      stream.next(m.fAccY);
      stream.next(m.fAccZ);
      stream.next(m.fAngRateX);
      stream.next(m.fAngRateY);
      stream.next(m.fAngRateZ);
      stream.next(m.fVelNorth);
      stream.next(m.fVelWest);
      stream.next(m.fVelUp);
      stream.next(m.fHeading);
      stream.next(m.fPitch);
      stream.next(m.fRoll);
      stream.next(m.nNavStatus);
      stream.next(m.vTimeStamp);
      stream.next(m.fSteeringAngle);
      stream.next(m.fSpeed);
      stream.next(m.fYawRate);
      stream.next(m.fFrontLeftWheelSpeed);
      stream.next(m.fFrontRightWheelSpeed);
      stream.next(m.fRearLeftWheelSpeed);
      stream.next(m.fRearRightWheelSpeed);
      stream.next(m.nShifterPosition);
      stream.next(m.nLeftDirectionLamp);
      stream.next(m.nRightDirectionLamp);
      stream.next(m.nMainBeamLamp);
      stream.next(m.nDippedBeamLamp);
      stream.next(m.nWiperState);
      stream.next(m.fLateralAccel);
      stream.next(m.fLongituAccel);
      stream.next(m.nLeftDrivenWheelPulseCounters);
      stream.next(m.nRightDrivenWheelPulseCounters);
      stream.next(m.nLeftNonDrivenWheelPulseCounters);
      stream.next(m.nRightNonDrivenWheelPulseCounters);
      stream.next(m.nDriveMode);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct ChassisMsg_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::radar_msgs::ChassisMsg_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::radar_msgs::ChassisMsg_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "isLessInfo: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.isLessInfo);
    s << indent << "reserved: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.reserved);
    s << indent << "VehDynYawRateHSC2: ";
    Printer<float>::stream(s, indent + "  ", v.VehDynYawRateHSC2);
    s << indent << "VehDynYawRateVHSC2: ";
    Printer<float>::stream(s, indent + "  ", v.VehDynYawRateVHSC2);
    s << indent << "TrShftLvrPos_h1HSC2: ";
    Printer<int32_t>::stream(s, indent + "  ", v.TrShftLvrPos_h1HSC2);
    s << indent << "TrShftLvrPosV_h1HSC2: ";
    Printer<int32_t>::stream(s, indent + "  ", v.TrShftLvrPosV_h1HSC2);
    s << indent << "VehSpdAvgDrvnHSC2: ";
    Printer<float>::stream(s, indent + "  ", v.VehSpdAvgDrvnHSC2);
    s << indent << "VehSpdAvgDrvnVHSC2: ";
    Printer<int32_t>::stream(s, indent + "  ", v.VehSpdAvgDrvnVHSC2);
    s << indent << "VehSpdAvgNonDrvnHSC2: ";
    Printer<float>::stream(s, indent + "  ", v.VehSpdAvgNonDrvnHSC2);
    s << indent << "VehSpdAvgNonDrvnVHSC2: ";
    Printer<int32_t>::stream(s, indent + "  ", v.VehSpdAvgNonDrvnVHSC2);
    s << indent << "StrgWhlAngHSC2: ";
    Printer<float>::stream(s, indent + "  ", v.StrgWhlAngHSC2);
    s << indent << "StrgWhlAngVHSC2: ";
    Printer<int32_t>::stream(s, indent + "  ", v.StrgWhlAngVHSC2);
    s << indent << "nCounter: ";
    Printer<int16_t>::stream(s, indent + "  ", v.nCounter);
    s << indent << "iTimeStamp: ";
    Printer<int64_t>::stream(s, indent + "  ", v.iTimeStamp);
    s << indent << "fLatitude: ";
    Printer<double>::stream(s, indent + "  ", v.fLatitude);
    s << indent << "fLongitude: ";
    Printer<double>::stream(s, indent + "  ", v.fLongitude);
    s << indent << "fAltitude: ";
    Printer<float>::stream(s, indent + "  ", v.fAltitude);
    s << indent << "fAccX: ";
    Printer<float>::stream(s, indent + "  ", v.fAccX);
    s << indent << "fAccY: ";
    Printer<float>::stream(s, indent + "  ", v.fAccY);
    s << indent << "fAccZ: ";
    Printer<float>::stream(s, indent + "  ", v.fAccZ);
    s << indent << "fAngRateX: ";
    Printer<float>::stream(s, indent + "  ", v.fAngRateX);
    s << indent << "fAngRateY: ";
    Printer<float>::stream(s, indent + "  ", v.fAngRateY);
    s << indent << "fAngRateZ: ";
    Printer<float>::stream(s, indent + "  ", v.fAngRateZ);
    s << indent << "fVelNorth: ";
    Printer<float>::stream(s, indent + "  ", v.fVelNorth);
    s << indent << "fVelWest: ";
    Printer<float>::stream(s, indent + "  ", v.fVelWest);
    s << indent << "fVelUp: ";
    Printer<float>::stream(s, indent + "  ", v.fVelUp);
    s << indent << "fHeading: ";
    Printer<float>::stream(s, indent + "  ", v.fHeading);
    s << indent << "fPitch: ";
    Printer<float>::stream(s, indent + "  ", v.fPitch);
    s << indent << "fRoll: ";
    Printer<float>::stream(s, indent + "  ", v.fRoll);
    s << indent << "nNavStatus: ";
    Printer<int8_t>::stream(s, indent + "  ", v.nNavStatus);
    s << indent << "vTimeStamp: ";
    Printer<int64_t>::stream(s, indent + "  ", v.vTimeStamp);
    s << indent << "fSteeringAngle: ";
    Printer<float>::stream(s, indent + "  ", v.fSteeringAngle);
    s << indent << "fSpeed: ";
    Printer<float>::stream(s, indent + "  ", v.fSpeed);
    s << indent << "fYawRate: ";
    Printer<float>::stream(s, indent + "  ", v.fYawRate);
    s << indent << "fFrontLeftWheelSpeed: ";
    Printer<float>::stream(s, indent + "  ", v.fFrontLeftWheelSpeed);
    s << indent << "fFrontRightWheelSpeed: ";
    Printer<float>::stream(s, indent + "  ", v.fFrontRightWheelSpeed);
    s << indent << "fRearLeftWheelSpeed: ";
    Printer<float>::stream(s, indent + "  ", v.fRearLeftWheelSpeed);
    s << indent << "fRearRightWheelSpeed: ";
    Printer<float>::stream(s, indent + "  ", v.fRearRightWheelSpeed);
    s << indent << "nShifterPosition: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.nShifterPosition);
    s << indent << "nLeftDirectionLamp: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.nLeftDirectionLamp);
    s << indent << "nRightDirectionLamp: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.nRightDirectionLamp);
    s << indent << "nMainBeamLamp: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.nMainBeamLamp);
    s << indent << "nDippedBeamLamp: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.nDippedBeamLamp);
    s << indent << "nWiperState: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.nWiperState);
    s << indent << "fLateralAccel: ";
    Printer<float>::stream(s, indent + "  ", v.fLateralAccel);
    s << indent << "fLongituAccel: ";
    Printer<float>::stream(s, indent + "  ", v.fLongituAccel);
    s << indent << "nLeftDrivenWheelPulseCounters: ";
    Printer<int16_t>::stream(s, indent + "  ", v.nLeftDrivenWheelPulseCounters);
    s << indent << "nRightDrivenWheelPulseCounters: ";
    Printer<int16_t>::stream(s, indent + "  ", v.nRightDrivenWheelPulseCounters);
    s << indent << "nLeftNonDrivenWheelPulseCounters: ";
    Printer<int16_t>::stream(s, indent + "  ", v.nLeftNonDrivenWheelPulseCounters);
    s << indent << "nRightNonDrivenWheelPulseCounters: ";
    Printer<int16_t>::stream(s, indent + "  ", v.nRightNonDrivenWheelPulseCounters);
    s << indent << "nDriveMode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.nDriveMode);
  }
};

} // namespace message_operations
} // namespace ros

#endif // RADAR_MSGS_MESSAGE_CHASSISMSG_H
