// Generated by gencpp from file radar_msgs/SystemStateNew.msg
// DO NOT EDIT!


#ifndef RADAR_MSGS_MESSAGE_SYSTEMSTATENEW_H
#define RADAR_MSGS_MESSAGE_SYSTEMSTATENEW_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace radar_msgs
{
template <class ContainerAllocator>
struct SystemStateNew_
{
  typedef SystemStateNew_<ContainerAllocator> Type;

  SystemStateNew_()
    : header()
    , projectCodeNum()
    , productYear(0)
    , productMonth(0)
    , productDay(0)
    , porductCode()
    , serialNum()
    , rfHwCode()
    , rfHwVersion(0)
    , dspHwCode()
    , dspHwVersion(0)
    , calibrateCode()
    , osVersion()
    , swVersion()
    , algoVersion()
    , waveformVersion()
    , a72_0_loading(0)
    , a72_1_loading(0)
    , a72_0_freq(0)
    , a72_1_freq(0)
    , mcu_0_freq(0)
    , mcu_1_freq(0)
    , mcu_2_freq(0)
    , mcu_3_freq(0)
    , lp_mcu_0_freq(0)
    , lp_mcu_1_freq(0)
    , c7x_mma_freq(0)
    , c66x_0_freq(0)
    , c66x_1_freq(0)
    , c7x_1_freq(0)
    , rebootCnt(0)
    , memoryLoading(0)
    , junctionTemp(0)
    , lowPowerModeEnable(0)
    , errorCode(0)
    , blockageDetection(0)
    , radarMode(0)
    , udpSendEnPnt(0)
    , udpSendEnTrk(0)
    , udpSendEnRDMap(0)
    , udpSendEnCfar(0)
    , udpSendEnAdc(0)
    , udpSendEnFft1D(0)
    , udpSendEnFft2D(0)
    , udpSendEnDOA(0)
    , radarTxFreq(0)
    , frameTriggerDelay(0)
    , syncEnable(0)
    , syncRadarNum(0)
    , antiInterfaceEnable(0)  {
      projectCodeNum.assign(0);

      porductCode.assign(0);

      serialNum.assign(0);

      rfHwCode.assign(0);

      dspHwCode.assign(0);

      calibrateCode.assign(0);

      osVersion.assign(0);

      swVersion.assign(0);

      algoVersion.assign(0);

      waveformVersion.assign(0);
  }
  SystemStateNew_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , projectCodeNum()
    , productYear(0)
    , productMonth(0)
    , productDay(0)
    , porductCode()
    , serialNum()
    , rfHwCode()
    , rfHwVersion(0)
    , dspHwCode()
    , dspHwVersion(0)
    , calibrateCode()
    , osVersion()
    , swVersion()
    , algoVersion()
    , waveformVersion()
    , a72_0_loading(0)
    , a72_1_loading(0)
    , a72_0_freq(0)
    , a72_1_freq(0)
    , mcu_0_freq(0)
    , mcu_1_freq(0)
    , mcu_2_freq(0)
    , mcu_3_freq(0)
    , lp_mcu_0_freq(0)
    , lp_mcu_1_freq(0)
    , c7x_mma_freq(0)
    , c66x_0_freq(0)
    , c66x_1_freq(0)
    , c7x_1_freq(0)
    , rebootCnt(0)
    , memoryLoading(0)
    , junctionTemp(0)
    , lowPowerModeEnable(0)
    , errorCode(0)
    , blockageDetection(0)
    , radarMode(0)
    , udpSendEnPnt(0)
    , udpSendEnTrk(0)
    , udpSendEnRDMap(0)
    , udpSendEnCfar(0)
    , udpSendEnAdc(0)
    , udpSendEnFft1D(0)
    , udpSendEnFft2D(0)
    , udpSendEnDOA(0)
    , radarTxFreq(0)
    , frameTriggerDelay(0)
    , syncEnable(0)
    , syncRadarNum(0)
    , antiInterfaceEnable(0)  {
  (void)_alloc;
      projectCodeNum.assign(0);

      porductCode.assign(0);

      serialNum.assign(0);

      rfHwCode.assign(0);

      dspHwCode.assign(0);

      calibrateCode.assign(0);

      osVersion.assign(0);

      swVersion.assign(0);

      algoVersion.assign(0);

      waveformVersion.assign(0);
  }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef boost::array<uint8_t, 20>  _projectCodeNum_type;
  _projectCodeNum_type projectCodeNum;

   typedef uint16_t _productYear_type;
  _productYear_type productYear;

   typedef uint16_t _productMonth_type;
  _productMonth_type productMonth;

   typedef uint16_t _productDay_type;
  _productDay_type productDay;

   typedef boost::array<uint8_t, 20>  _porductCode_type;
  _porductCode_type porductCode;

   typedef boost::array<uint8_t, 40>  _serialNum_type;
  _serialNum_type serialNum;

   typedef boost::array<uint8_t, 40>  _rfHwCode_type;
  _rfHwCode_type rfHwCode;

   typedef uint16_t _rfHwVersion_type;
  _rfHwVersion_type rfHwVersion;

   typedef boost::array<uint8_t, 40>  _dspHwCode_type;
  _dspHwCode_type dspHwCode;

   typedef uint16_t _dspHwVersion_type;
  _dspHwVersion_type dspHwVersion;

   typedef boost::array<uint8_t, 20>  _calibrateCode_type;
  _calibrateCode_type calibrateCode;

   typedef boost::array<uint8_t, 20>  _osVersion_type;
  _osVersion_type osVersion;

   typedef boost::array<uint8_t, 20>  _swVersion_type;
  _swVersion_type swVersion;

   typedef boost::array<uint8_t, 20>  _algoVersion_type;
  _algoVersion_type algoVersion;

   typedef boost::array<uint8_t, 20>  _waveformVersion_type;
  _waveformVersion_type waveformVersion;

   typedef uint16_t _a72_0_loading_type;
  _a72_0_loading_type a72_0_loading;

   typedef uint16_t _a72_1_loading_type;
  _a72_1_loading_type a72_1_loading;

   typedef uint32_t _a72_0_freq_type;
  _a72_0_freq_type a72_0_freq;

   typedef uint32_t _a72_1_freq_type;
  _a72_1_freq_type a72_1_freq;

   typedef uint32_t _mcu_0_freq_type;
  _mcu_0_freq_type mcu_0_freq;

   typedef uint32_t _mcu_1_freq_type;
  _mcu_1_freq_type mcu_1_freq;

   typedef uint32_t _mcu_2_freq_type;
  _mcu_2_freq_type mcu_2_freq;

   typedef uint32_t _mcu_3_freq_type;
  _mcu_3_freq_type mcu_3_freq;

   typedef uint32_t _lp_mcu_0_freq_type;
  _lp_mcu_0_freq_type lp_mcu_0_freq;

   typedef uint32_t _lp_mcu_1_freq_type;
  _lp_mcu_1_freq_type lp_mcu_1_freq;

   typedef uint32_t _c7x_mma_freq_type;
  _c7x_mma_freq_type c7x_mma_freq;

   typedef uint32_t _c66x_0_freq_type;
  _c66x_0_freq_type c66x_0_freq;

   typedef uint32_t _c66x_1_freq_type;
  _c66x_1_freq_type c66x_1_freq;

   typedef uint32_t _c7x_1_freq_type;
  _c7x_1_freq_type c7x_1_freq;

   typedef uint16_t _rebootCnt_type;
  _rebootCnt_type rebootCnt;

   typedef uint16_t _memoryLoading_type;
  _memoryLoading_type memoryLoading;

   typedef uint32_t _junctionTemp_type;
  _junctionTemp_type junctionTemp;

   typedef uint16_t _lowPowerModeEnable_type;
  _lowPowerModeEnable_type lowPowerModeEnable;

   typedef uint16_t _errorCode_type;
  _errorCode_type errorCode;

   typedef uint16_t _blockageDetection_type;
  _blockageDetection_type blockageDetection;

   typedef uint16_t _radarMode_type;
  _radarMode_type radarMode;

   typedef uint16_t _udpSendEnPnt_type;
  _udpSendEnPnt_type udpSendEnPnt;

   typedef uint16_t _udpSendEnTrk_type;
  _udpSendEnTrk_type udpSendEnTrk;

   typedef uint16_t _udpSendEnRDMap_type;
  _udpSendEnRDMap_type udpSendEnRDMap;

   typedef uint16_t _udpSendEnCfar_type;
  _udpSendEnCfar_type udpSendEnCfar;

   typedef uint16_t _udpSendEnAdc_type;
  _udpSendEnAdc_type udpSendEnAdc;

   typedef uint16_t _udpSendEnFft1D_type;
  _udpSendEnFft1D_type udpSendEnFft1D;

   typedef uint16_t _udpSendEnFft2D_type;
  _udpSendEnFft2D_type udpSendEnFft2D;

   typedef uint16_t _udpSendEnDOA_type;
  _udpSendEnDOA_type udpSendEnDOA;

   typedef uint16_t _radarTxFreq_type;
  _radarTxFreq_type radarTxFreq;

   typedef uint16_t _frameTriggerDelay_type;
  _frameTriggerDelay_type frameTriggerDelay;

   typedef uint16_t _syncEnable_type;
  _syncEnable_type syncEnable;

   typedef uint16_t _syncRadarNum_type;
  _syncRadarNum_type syncRadarNum;

   typedef uint16_t _antiInterfaceEnable_type;
  _antiInterfaceEnable_type antiInterfaceEnable;





  typedef boost::shared_ptr< ::radar_msgs::SystemStateNew_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::radar_msgs::SystemStateNew_<ContainerAllocator> const> ConstPtr;

}; // struct SystemStateNew_

typedef ::radar_msgs::SystemStateNew_<std::allocator<void> > SystemStateNew;

typedef boost::shared_ptr< ::radar_msgs::SystemStateNew > SystemStateNewPtr;
typedef boost::shared_ptr< ::radar_msgs::SystemStateNew const> SystemStateNewConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::radar_msgs::SystemStateNew_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::radar_msgs::SystemStateNew_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::radar_msgs::SystemStateNew_<ContainerAllocator1> & lhs, const ::radar_msgs::SystemStateNew_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.projectCodeNum == rhs.projectCodeNum &&
    lhs.productYear == rhs.productYear &&
    lhs.productMonth == rhs.productMonth &&
    lhs.productDay == rhs.productDay &&
    lhs.porductCode == rhs.porductCode &&
    lhs.serialNum == rhs.serialNum &&
    lhs.rfHwCode == rhs.rfHwCode &&
    lhs.rfHwVersion == rhs.rfHwVersion &&
    lhs.dspHwCode == rhs.dspHwCode &&
    lhs.dspHwVersion == rhs.dspHwVersion &&
    lhs.calibrateCode == rhs.calibrateCode &&
    lhs.osVersion == rhs.osVersion &&
    lhs.swVersion == rhs.swVersion &&
    lhs.algoVersion == rhs.algoVersion &&
    lhs.waveformVersion == rhs.waveformVersion &&
    lhs.a72_0_loading == rhs.a72_0_loading &&
    lhs.a72_1_loading == rhs.a72_1_loading &&
    lhs.a72_0_freq == rhs.a72_0_freq &&
    lhs.a72_1_freq == rhs.a72_1_freq &&
    lhs.mcu_0_freq == rhs.mcu_0_freq &&
    lhs.mcu_1_freq == rhs.mcu_1_freq &&
    lhs.mcu_2_freq == rhs.mcu_2_freq &&
    lhs.mcu_3_freq == rhs.mcu_3_freq &&
    lhs.lp_mcu_0_freq == rhs.lp_mcu_0_freq &&
    lhs.lp_mcu_1_freq == rhs.lp_mcu_1_freq &&
    lhs.c7x_mma_freq == rhs.c7x_mma_freq &&
    lhs.c66x_0_freq == rhs.c66x_0_freq &&
    lhs.c66x_1_freq == rhs.c66x_1_freq &&
    lhs.c7x_1_freq == rhs.c7x_1_freq &&
    lhs.rebootCnt == rhs.rebootCnt &&
    lhs.memoryLoading == rhs.memoryLoading &&
    lhs.junctionTemp == rhs.junctionTemp &&
    lhs.lowPowerModeEnable == rhs.lowPowerModeEnable &&
    lhs.errorCode == rhs.errorCode &&
    lhs.blockageDetection == rhs.blockageDetection &&
    lhs.radarMode == rhs.radarMode &&
    lhs.udpSendEnPnt == rhs.udpSendEnPnt &&
    lhs.udpSendEnTrk == rhs.udpSendEnTrk &&
    lhs.udpSendEnRDMap == rhs.udpSendEnRDMap &&
    lhs.udpSendEnCfar == rhs.udpSendEnCfar &&
    lhs.udpSendEnAdc == rhs.udpSendEnAdc &&
    lhs.udpSendEnFft1D == rhs.udpSendEnFft1D &&
    lhs.udpSendEnFft2D == rhs.udpSendEnFft2D &&
    lhs.udpSendEnDOA == rhs.udpSendEnDOA &&
    lhs.radarTxFreq == rhs.radarTxFreq &&
    lhs.frameTriggerDelay == rhs.frameTriggerDelay &&
    lhs.syncEnable == rhs.syncEnable &&
    lhs.syncRadarNum == rhs.syncRadarNum &&
    lhs.antiInterfaceEnable == rhs.antiInterfaceEnable;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::radar_msgs::SystemStateNew_<ContainerAllocator1> & lhs, const ::radar_msgs::SystemStateNew_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace radar_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::radar_msgs::SystemStateNew_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::radar_msgs::SystemStateNew_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::radar_msgs::SystemStateNew_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::radar_msgs::SystemStateNew_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::radar_msgs::SystemStateNew_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::radar_msgs::SystemStateNew_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::radar_msgs::SystemStateNew_<ContainerAllocator> >
{
  static const char* value()
  {
    return "5cd1f98266d88da5518e239931fd3c7a";
  }

  static const char* value(const ::radar_msgs::SystemStateNew_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x5cd1f98266d88da5ULL;
  static const uint64_t static_value2 = 0x518e239931fd3c7aULL;
};

template<class ContainerAllocator>
struct DataType< ::radar_msgs::SystemStateNew_<ContainerAllocator> >
{
  static const char* value()
  {
    return "radar_msgs/SystemStateNew";
  }

  static const char* value(const ::radar_msgs::SystemStateNew_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::radar_msgs::SystemStateNew_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header                      header  # Includes measurement timestamp and coordinate frame.\n"
"char[20]                    projectCodeNum #project number\n"
"uint16                      productYear #manufacture date: year since 2000\n"
"uint16                      productMonth #manufacture date: month\n"
"uint16                      productDay #manufacture date: day\n"
"char[20]                    porductCode\n"
"char[40]                    serialNum\n"
"char[40]                    rfHwCode\n"
"uint16                      rfHwVersion\n"
"char[40]                    dspHwCode\n"
"uint16                      dspHwVersion\n"
"char[20]                    calibrateCode\n"
"char[20]                    osVersion\n"
"char[20]                    swVersion\n"
"char[20]                    algoVersion\n"
"char[20]                    waveformVersion\n"
"uint16                      a72_0_loading\n"
"uint16                      a72_1_loading\n"
"uint32                      a72_0_freq\n"
"uint32                      a72_1_freq\n"
"uint32                      mcu_0_freq\n"
"uint32                      mcu_1_freq\n"
"uint32                      mcu_2_freq\n"
"uint32                      mcu_3_freq\n"
"uint32                      lp_mcu_0_freq\n"
"uint32                      lp_mcu_1_freq\n"
"uint32                      c7x_mma_freq\n"
"uint32                      c66x_0_freq\n"
"uint32                      c66x_1_freq\n"
"uint32                      c7x_1_freq\n"
"uint16                      rebootCnt\n"
"uint16                      memoryLoading\n"
"uint32                      junctionTemp\n"
"uint16                      lowPowerModeEnable\n"
"uint16                      errorCode\n"
"uint16                      blockageDetection\n"
"uint16                      radarMode\n"
"uint16                      udpSendEnPnt\n"
"uint16                      udpSendEnTrk\n"
"uint16                      udpSendEnRDMap\n"
"uint16                      udpSendEnCfar\n"
"uint16                      udpSendEnAdc\n"
"uint16                      udpSendEnFft1D\n"
"uint16                      udpSendEnFft2D\n"
"uint16                      udpSendEnDOA\n"
"uint16                      radarTxFreq\n"
"uint16                      frameTriggerDelay\n"
"uint16                      syncEnable\n"
"uint16                      syncRadarNum\n"
"uint16                      antiInterfaceEnable\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::radar_msgs::SystemStateNew_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::radar_msgs::SystemStateNew_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.projectCodeNum);
      stream.next(m.productYear);
      stream.next(m.productMonth);
      stream.next(m.productDay);
      stream.next(m.porductCode);
      stream.next(m.serialNum);
      stream.next(m.rfHwCode);
      stream.next(m.rfHwVersion);
      stream.next(m.dspHwCode);
      stream.next(m.dspHwVersion);
      stream.next(m.calibrateCode);
      stream.next(m.osVersion);
      stream.next(m.swVersion);
      stream.next(m.algoVersion);
      stream.next(m.waveformVersion);
      stream.next(m.a72_0_loading);
      stream.next(m.a72_1_loading);
      stream.next(m.a72_0_freq);
      stream.next(m.a72_1_freq);
      stream.next(m.mcu_0_freq);
      stream.next(m.mcu_1_freq);
      stream.next(m.mcu_2_freq);
      stream.next(m.mcu_3_freq);
      stream.next(m.lp_mcu_0_freq);
      stream.next(m.lp_mcu_1_freq);
      stream.next(m.c7x_mma_freq);
      stream.next(m.c66x_0_freq);
      stream.next(m.c66x_1_freq);
      stream.next(m.c7x_1_freq);
      stream.next(m.rebootCnt);
      stream.next(m.memoryLoading);
      stream.next(m.junctionTemp);
      stream.next(m.lowPowerModeEnable);
      stream.next(m.errorCode);
      stream.next(m.blockageDetection);
      stream.next(m.radarMode);
      stream.next(m.udpSendEnPnt);
      stream.next(m.udpSendEnTrk);
      stream.next(m.udpSendEnRDMap);
      stream.next(m.udpSendEnCfar);
      stream.next(m.udpSendEnAdc);
      stream.next(m.udpSendEnFft1D);
      stream.next(m.udpSendEnFft2D);
      stream.next(m.udpSendEnDOA);
      stream.next(m.radarTxFreq);
      stream.next(m.frameTriggerDelay);
      stream.next(m.syncEnable);
      stream.next(m.syncRadarNum);
      stream.next(m.antiInterfaceEnable);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct SystemStateNew_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::radar_msgs::SystemStateNew_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::radar_msgs::SystemStateNew_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "projectCodeNum[]" << std::endl;
    for (size_t i = 0; i < v.projectCodeNum.size(); ++i)
    {
      s << indent << "  projectCodeNum[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.projectCodeNum[i]);
    }
    s << indent << "productYear: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.productYear);
    s << indent << "productMonth: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.productMonth);
    s << indent << "productDay: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.productDay);
    s << indent << "porductCode[]" << std::endl;
    for (size_t i = 0; i < v.porductCode.size(); ++i)
    {
      s << indent << "  porductCode[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.porductCode[i]);
    }
    s << indent << "serialNum[]" << std::endl;
    for (size_t i = 0; i < v.serialNum.size(); ++i)
    {
      s << indent << "  serialNum[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.serialNum[i]);
    }
    s << indent << "rfHwCode[]" << std::endl;
    for (size_t i = 0; i < v.rfHwCode.size(); ++i)
    {
      s << indent << "  rfHwCode[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.rfHwCode[i]);
    }
    s << indent << "rfHwVersion: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.rfHwVersion);
    s << indent << "dspHwCode[]" << std::endl;
    for (size_t i = 0; i < v.dspHwCode.size(); ++i)
    {
      s << indent << "  dspHwCode[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.dspHwCode[i]);
    }
    s << indent << "dspHwVersion: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.dspHwVersion);
    s << indent << "calibrateCode[]" << std::endl;
    for (size_t i = 0; i < v.calibrateCode.size(); ++i)
    {
      s << indent << "  calibrateCode[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.calibrateCode[i]);
    }
    s << indent << "osVersion[]" << std::endl;
    for (size_t i = 0; i < v.osVersion.size(); ++i)
    {
      s << indent << "  osVersion[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.osVersion[i]);
    }
    s << indent << "swVersion[]" << std::endl;
    for (size_t i = 0; i < v.swVersion.size(); ++i)
    {
      s << indent << "  swVersion[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.swVersion[i]);
    }
    s << indent << "algoVersion[]" << std::endl;
    for (size_t i = 0; i < v.algoVersion.size(); ++i)
    {
      s << indent << "  algoVersion[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.algoVersion[i]);
    }
    s << indent << "waveformVersion[]" << std::endl;
    for (size_t i = 0; i < v.waveformVersion.size(); ++i)
    {
      s << indent << "  waveformVersion[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.waveformVersion[i]);
    }
    s << indent << "a72_0_loading: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.a72_0_loading);
    s << indent << "a72_1_loading: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.a72_1_loading);
    s << indent << "a72_0_freq: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.a72_0_freq);
    s << indent << "a72_1_freq: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.a72_1_freq);
    s << indent << "mcu_0_freq: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.mcu_0_freq);
    s << indent << "mcu_1_freq: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.mcu_1_freq);
    s << indent << "mcu_2_freq: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.mcu_2_freq);
    s << indent << "mcu_3_freq: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.mcu_3_freq);
    s << indent << "lp_mcu_0_freq: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.lp_mcu_0_freq);
    s << indent << "lp_mcu_1_freq: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.lp_mcu_1_freq);
    s << indent << "c7x_mma_freq: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.c7x_mma_freq);
    s << indent << "c66x_0_freq: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.c66x_0_freq);
    s << indent << "c66x_1_freq: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.c66x_1_freq);
    s << indent << "c7x_1_freq: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.c7x_1_freq);
    s << indent << "rebootCnt: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.rebootCnt);
    s << indent << "memoryLoading: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.memoryLoading);
    s << indent << "junctionTemp: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.junctionTemp);
    s << indent << "lowPowerModeEnable: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.lowPowerModeEnable);
    s << indent << "errorCode: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.errorCode);
    s << indent << "blockageDetection: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.blockageDetection);
    s << indent << "radarMode: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.radarMode);
    s << indent << "udpSendEnPnt: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.udpSendEnPnt);
    s << indent << "udpSendEnTrk: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.udpSendEnTrk);
    s << indent << "udpSendEnRDMap: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.udpSendEnRDMap);
    s << indent << "udpSendEnCfar: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.udpSendEnCfar);
    s << indent << "udpSendEnAdc: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.udpSendEnAdc);
    s << indent << "udpSendEnFft1D: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.udpSendEnFft1D);
    s << indent << "udpSendEnFft2D: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.udpSendEnFft2D);
    s << indent << "udpSendEnDOA: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.udpSendEnDOA);
    s << indent << "radarTxFreq: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.radarTxFreq);
    s << indent << "frameTriggerDelay: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.frameTriggerDelay);
    s << indent << "syncEnable: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.syncEnable);
    s << indent << "syncRadarNum: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.syncRadarNum);
    s << indent << "antiInterfaceEnable: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.antiInterfaceEnable);
  }
};

} // namespace message_operations
} // namespace ros

#endif // RADAR_MSGS_MESSAGE_SYSTEMSTATENEW_H
