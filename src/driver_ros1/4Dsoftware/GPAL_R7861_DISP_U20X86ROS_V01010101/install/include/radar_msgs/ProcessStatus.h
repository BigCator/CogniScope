// Generated by gencpp from file radar_msgs/ProcessStatus.msg
// DO NOT EDIT!


#ifndef RADAR_MSGS_MESSAGE_PROCESSSTATUS_H
#define RADAR_MSGS_MESSAGE_PROCESSSTATUS_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace radar_msgs
{
template <class ContainerAllocator>
struct ProcessStatus_
{
  typedef ProcessStatus_<ContainerAllocator> Type;

  ProcessStatus_()
    : header()
    , radarID(0)
    , frameCnt(0)
    , captureTime(0.0)
    , frameLostCnt(0)
    , adcErrCnt(0)
    , reserved_a(0)
    , reserved_b(0)
    , time1DFFT(0.0)
    , reserved_c(0)
    , reserved_d(0)
    , reserved_e(0)
    , reserved_f(0)
    , time2DFFT(0.0)
    , reserved_g(0)
    , reserved_h(0)
    , reserved_i(0)
    , reserved_j(0)
    , timeRDMap(0.0)
    , reserved_k(0)
    , reserved_l(0)
    , reserved_m(0)
    , reserved_n(0)
    , timeCfar(0.0)
    , reserved_o(0)
    , reserved_p(0)
    , reserved_q(0)
    , reserved_r(0)
    , timeDOA(0.0)
    , reserved_s(0)
    , reserved_t(0)
    , reserved_u(0)
    , reserved_v(0)
    , timePCL(0.0)
    , reserved_w(0)
    , reserved_x(0)
    , reserved_y(0)
    , reserved_z(0)
    , timeOD(0.0)
    , odTimeoutCnt(0)
    , selfCaliStatus(0)
    , reserved_aa(0)
    , reserved_ab(0)
    , reserved_ac(0)
    , reserved_ad(0)  {
    }
  ProcessStatus_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , radarID(0)
    , frameCnt(0)
    , captureTime(0.0)
    , frameLostCnt(0)
    , adcErrCnt(0)
    , reserved_a(0)
    , reserved_b(0)
    , time1DFFT(0.0)
    , reserved_c(0)
    , reserved_d(0)
    , reserved_e(0)
    , reserved_f(0)
    , time2DFFT(0.0)
    , reserved_g(0)
    , reserved_h(0)
    , reserved_i(0)
    , reserved_j(0)
    , timeRDMap(0.0)
    , reserved_k(0)
    , reserved_l(0)
    , reserved_m(0)
    , reserved_n(0)
    , timeCfar(0.0)
    , reserved_o(0)
    , reserved_p(0)
    , reserved_q(0)
    , reserved_r(0)
    , timeDOA(0.0)
    , reserved_s(0)
    , reserved_t(0)
    , reserved_u(0)
    , reserved_v(0)
    , timePCL(0.0)
    , reserved_w(0)
    , reserved_x(0)
    , reserved_y(0)
    , reserved_z(0)
    , timeOD(0.0)
    , odTimeoutCnt(0)
    , selfCaliStatus(0)
    , reserved_aa(0)
    , reserved_ab(0)
    , reserved_ac(0)
    , reserved_ad(0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef uint32_t _radarID_type;
  _radarID_type radarID;

   typedef uint32_t _frameCnt_type;
  _frameCnt_type frameCnt;

   typedef float _captureTime_type;
  _captureTime_type captureTime;

   typedef uint32_t _frameLostCnt_type;
  _frameLostCnt_type frameLostCnt;

   typedef uint32_t _adcErrCnt_type;
  _adcErrCnt_type adcErrCnt;

   typedef uint32_t _reserved_a_type;
  _reserved_a_type reserved_a;

   typedef uint32_t _reserved_b_type;
  _reserved_b_type reserved_b;

   typedef float _time1DFFT_type;
  _time1DFFT_type time1DFFT;

   typedef uint32_t _reserved_c_type;
  _reserved_c_type reserved_c;

   typedef uint32_t _reserved_d_type;
  _reserved_d_type reserved_d;

   typedef uint32_t _reserved_e_type;
  _reserved_e_type reserved_e;

   typedef uint32_t _reserved_f_type;
  _reserved_f_type reserved_f;

   typedef float _time2DFFT_type;
  _time2DFFT_type time2DFFT;

   typedef uint32_t _reserved_g_type;
  _reserved_g_type reserved_g;

   typedef uint32_t _reserved_h_type;
  _reserved_h_type reserved_h;

   typedef uint32_t _reserved_i_type;
  _reserved_i_type reserved_i;

   typedef uint32_t _reserved_j_type;
  _reserved_j_type reserved_j;

   typedef float _timeRDMap_type;
  _timeRDMap_type timeRDMap;

   typedef uint32_t _reserved_k_type;
  _reserved_k_type reserved_k;

   typedef uint32_t _reserved_l_type;
  _reserved_l_type reserved_l;

   typedef uint32_t _reserved_m_type;
  _reserved_m_type reserved_m;

   typedef uint32_t _reserved_n_type;
  _reserved_n_type reserved_n;

   typedef float _timeCfar_type;
  _timeCfar_type timeCfar;

   typedef uint32_t _reserved_o_type;
  _reserved_o_type reserved_o;

   typedef uint32_t _reserved_p_type;
  _reserved_p_type reserved_p;

   typedef uint32_t _reserved_q_type;
  _reserved_q_type reserved_q;

   typedef uint32_t _reserved_r_type;
  _reserved_r_type reserved_r;

   typedef float _timeDOA_type;
  _timeDOA_type timeDOA;

   typedef uint32_t _reserved_s_type;
  _reserved_s_type reserved_s;

   typedef uint32_t _reserved_t_type;
  _reserved_t_type reserved_t;

   typedef uint32_t _reserved_u_type;
  _reserved_u_type reserved_u;

   typedef uint32_t _reserved_v_type;
  _reserved_v_type reserved_v;

   typedef float _timePCL_type;
  _timePCL_type timePCL;

   typedef uint32_t _reserved_w_type;
  _reserved_w_type reserved_w;

   typedef uint32_t _reserved_x_type;
  _reserved_x_type reserved_x;

   typedef uint32_t _reserved_y_type;
  _reserved_y_type reserved_y;

   typedef uint32_t _reserved_z_type;
  _reserved_z_type reserved_z;

   typedef float _timeOD_type;
  _timeOD_type timeOD;

   typedef uint32_t _odTimeoutCnt_type;
  _odTimeoutCnt_type odTimeoutCnt;

   typedef int32_t _selfCaliStatus_type;
  _selfCaliStatus_type selfCaliStatus;

   typedef uint32_t _reserved_aa_type;
  _reserved_aa_type reserved_aa;

   typedef uint32_t _reserved_ab_type;
  _reserved_ab_type reserved_ab;

   typedef uint32_t _reserved_ac_type;
  _reserved_ac_type reserved_ac;

   typedef uint32_t _reserved_ad_type;
  _reserved_ad_type reserved_ad;





  typedef boost::shared_ptr< ::radar_msgs::ProcessStatus_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::radar_msgs::ProcessStatus_<ContainerAllocator> const> ConstPtr;

}; // struct ProcessStatus_

typedef ::radar_msgs::ProcessStatus_<std::allocator<void> > ProcessStatus;

typedef boost::shared_ptr< ::radar_msgs::ProcessStatus > ProcessStatusPtr;
typedef boost::shared_ptr< ::radar_msgs::ProcessStatus const> ProcessStatusConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::radar_msgs::ProcessStatus_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::radar_msgs::ProcessStatus_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::radar_msgs::ProcessStatus_<ContainerAllocator1> & lhs, const ::radar_msgs::ProcessStatus_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.radarID == rhs.radarID &&
    lhs.frameCnt == rhs.frameCnt &&
    lhs.captureTime == rhs.captureTime &&
    lhs.frameLostCnt == rhs.frameLostCnt &&
    lhs.adcErrCnt == rhs.adcErrCnt &&
    lhs.reserved_a == rhs.reserved_a &&
    lhs.reserved_b == rhs.reserved_b &&
    lhs.time1DFFT == rhs.time1DFFT &&
    lhs.reserved_c == rhs.reserved_c &&
    lhs.reserved_d == rhs.reserved_d &&
    lhs.reserved_e == rhs.reserved_e &&
    lhs.reserved_f == rhs.reserved_f &&
    lhs.time2DFFT == rhs.time2DFFT &&
    lhs.reserved_g == rhs.reserved_g &&
    lhs.reserved_h == rhs.reserved_h &&
    lhs.reserved_i == rhs.reserved_i &&
    lhs.reserved_j == rhs.reserved_j &&
    lhs.timeRDMap == rhs.timeRDMap &&
    lhs.reserved_k == rhs.reserved_k &&
    lhs.reserved_l == rhs.reserved_l &&
    lhs.reserved_m == rhs.reserved_m &&
    lhs.reserved_n == rhs.reserved_n &&
    lhs.timeCfar == rhs.timeCfar &&
    lhs.reserved_o == rhs.reserved_o &&
    lhs.reserved_p == rhs.reserved_p &&
    lhs.reserved_q == rhs.reserved_q &&
    lhs.reserved_r == rhs.reserved_r &&
    lhs.timeDOA == rhs.timeDOA &&
    lhs.reserved_s == rhs.reserved_s &&
    lhs.reserved_t == rhs.reserved_t &&
    lhs.reserved_u == rhs.reserved_u &&
    lhs.reserved_v == rhs.reserved_v &&
    lhs.timePCL == rhs.timePCL &&
    lhs.reserved_w == rhs.reserved_w &&
    lhs.reserved_x == rhs.reserved_x &&
    lhs.reserved_y == rhs.reserved_y &&
    lhs.reserved_z == rhs.reserved_z &&
    lhs.timeOD == rhs.timeOD &&
    lhs.odTimeoutCnt == rhs.odTimeoutCnt &&
    lhs.selfCaliStatus == rhs.selfCaliStatus &&
    lhs.reserved_aa == rhs.reserved_aa &&
    lhs.reserved_ab == rhs.reserved_ab &&
    lhs.reserved_ac == rhs.reserved_ac &&
    lhs.reserved_ad == rhs.reserved_ad;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::radar_msgs::ProcessStatus_<ContainerAllocator1> & lhs, const ::radar_msgs::ProcessStatus_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace radar_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::radar_msgs::ProcessStatus_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::radar_msgs::ProcessStatus_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::radar_msgs::ProcessStatus_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::radar_msgs::ProcessStatus_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::radar_msgs::ProcessStatus_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::radar_msgs::ProcessStatus_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::radar_msgs::ProcessStatus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "3b68402e7d30a9e6144470a4717d74aa";
  }

  static const char* value(const ::radar_msgs::ProcessStatus_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x3b68402e7d30a9e6ULL;
  static const uint64_t static_value2 = 0x144470a4717d74aaULL;
};

template<class ContainerAllocator>
struct DataType< ::radar_msgs::ProcessStatus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "radar_msgs/ProcessStatus";
  }

  static const char* value(const ::radar_msgs::ProcessStatus_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::radar_msgs::ProcessStatus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header                   # Includes measurement timestamp and coordinate frame.\n"
"uint32 radarID                  # radar ID\n"
"uint32 frameCnt                 # frame cnt in radar\n"
"float32 captureTime              # LSB=ms\n"
"uint32 frameLostCnt             \n"
"uint32 adcErrCnt       \n"
"uint32 reserved_a\n"
"uint32 reserved_b\n"
"float32 time1DFFT                # LSB=ms\n"
"uint32 reserved_c\n"
"uint32 reserved_d\n"
"uint32 reserved_e\n"
"uint32 reserved_f\n"
"float32 time2DFFT                # LSB=ms\n"
"uint32 reserved_g\n"
"uint32 reserved_h\n"
"uint32 reserved_i\n"
"uint32 reserved_j\n"
"float32 timeRDMap                # LSB=ms\n"
"uint32 reserved_k\n"
"uint32 reserved_l\n"
"uint32 reserved_m\n"
"uint32 reserved_n\n"
"float32 timeCfar                 # LSB=ms\n"
"uint32 reserved_o\n"
"uint32 reserved_p\n"
"uint32 reserved_q\n"
"uint32 reserved_r\n"
"float32 timeDOA                  # LSB=ms\n"
"uint32 reserved_s\n"
"uint32 reserved_t\n"
"uint32 reserved_u\n"
"uint32 reserved_v\n"
"float32 timePCL                  # LSB=ms\n"
"uint32 reserved_w                # velocity Estimated\n"
"uint32 reserved_x                # ground K\n"
"uint32 reserved_y                # ground B\n"
"uint32 reserved_z                # pcl delay time, LSB = 0.1ms\n"
"float32 timeOD                   # LSB=ms\n"
"uint32 odTimeoutCnt             \n"
"int32  selfCaliStatus           # 0: cali fails; 1: pre-cali; 1~99: calibrating(in process); 100: cali success\n"
"uint32 reserved_aa              # od delay time, LSB = 0.1ms\n"
"uint32 reserved_ab\n"
"uint32 reserved_ac\n"
"uint32 reserved_ad\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::radar_msgs::ProcessStatus_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::radar_msgs::ProcessStatus_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.radarID);
      stream.next(m.frameCnt);
      stream.next(m.captureTime);
      stream.next(m.frameLostCnt);
      stream.next(m.adcErrCnt);
      stream.next(m.reserved_a);
      stream.next(m.reserved_b);
      stream.next(m.time1DFFT);
      stream.next(m.reserved_c);
      stream.next(m.reserved_d);
      stream.next(m.reserved_e);
      stream.next(m.reserved_f);
      stream.next(m.time2DFFT);
      stream.next(m.reserved_g);
      stream.next(m.reserved_h);
      stream.next(m.reserved_i);
      stream.next(m.reserved_j);
      stream.next(m.timeRDMap);
      stream.next(m.reserved_k);
      stream.next(m.reserved_l);
      stream.next(m.reserved_m);
      stream.next(m.reserved_n);
      stream.next(m.timeCfar);
      stream.next(m.reserved_o);
      stream.next(m.reserved_p);
      stream.next(m.reserved_q);
      stream.next(m.reserved_r);
      stream.next(m.timeDOA);
      stream.next(m.reserved_s);
      stream.next(m.reserved_t);
      stream.next(m.reserved_u);
      stream.next(m.reserved_v);
      stream.next(m.timePCL);
      stream.next(m.reserved_w);
      stream.next(m.reserved_x);
      stream.next(m.reserved_y);
      stream.next(m.reserved_z);
      stream.next(m.timeOD);
      stream.next(m.odTimeoutCnt);
      stream.next(m.selfCaliStatus);
      stream.next(m.reserved_aa);
      stream.next(m.reserved_ab);
      stream.next(m.reserved_ac);
      stream.next(m.reserved_ad);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct ProcessStatus_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::radar_msgs::ProcessStatus_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::radar_msgs::ProcessStatus_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "radarID: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.radarID);
    s << indent << "frameCnt: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.frameCnt);
    s << indent << "captureTime: ";
    Printer<float>::stream(s, indent + "  ", v.captureTime);
    s << indent << "frameLostCnt: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.frameLostCnt);
    s << indent << "adcErrCnt: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.adcErrCnt);
    s << indent << "reserved_a: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_a);
    s << indent << "reserved_b: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_b);
    s << indent << "time1DFFT: ";
    Printer<float>::stream(s, indent + "  ", v.time1DFFT);
    s << indent << "reserved_c: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_c);
    s << indent << "reserved_d: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_d);
    s << indent << "reserved_e: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_e);
    s << indent << "reserved_f: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_f);
    s << indent << "time2DFFT: ";
    Printer<float>::stream(s, indent + "  ", v.time2DFFT);
    s << indent << "reserved_g: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_g);
    s << indent << "reserved_h: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_h);
    s << indent << "reserved_i: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_i);
    s << indent << "reserved_j: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_j);
    s << indent << "timeRDMap: ";
    Printer<float>::stream(s, indent + "  ", v.timeRDMap);
    s << indent << "reserved_k: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_k);
    s << indent << "reserved_l: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_l);
    s << indent << "reserved_m: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_m);
    s << indent << "reserved_n: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_n);
    s << indent << "timeCfar: ";
    Printer<float>::stream(s, indent + "  ", v.timeCfar);
    s << indent << "reserved_o: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_o);
    s << indent << "reserved_p: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_p);
    s << indent << "reserved_q: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_q);
    s << indent << "reserved_r: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_r);
    s << indent << "timeDOA: ";
    Printer<float>::stream(s, indent + "  ", v.timeDOA);
    s << indent << "reserved_s: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_s);
    s << indent << "reserved_t: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_t);
    s << indent << "reserved_u: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_u);
    s << indent << "reserved_v: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_v);
    s << indent << "timePCL: ";
    Printer<float>::stream(s, indent + "  ", v.timePCL);
    s << indent << "reserved_w: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_w);
    s << indent << "reserved_x: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_x);
    s << indent << "reserved_y: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_y);
    s << indent << "reserved_z: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_z);
    s << indent << "timeOD: ";
    Printer<float>::stream(s, indent + "  ", v.timeOD);
    s << indent << "odTimeoutCnt: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.odTimeoutCnt);
    s << indent << "selfCaliStatus: ";
    Printer<int32_t>::stream(s, indent + "  ", v.selfCaliStatus);
    s << indent << "reserved_aa: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_aa);
    s << indent << "reserved_ab: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_ab);
    s << indent << "reserved_ac: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_ac);
    s << indent << "reserved_ad: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved_ad);
  }
};

} // namespace message_operations
} // namespace ros

#endif // RADAR_MSGS_MESSAGE_PROCESSSTATUS_H
