// Generated by gencpp from file radar_msgs/RlMonTxPhShiftRep.msg
// DO NOT EDIT!


#ifndef RADAR_MSGS_MESSAGE_RLMONTXPHSHIFTREP_H
#define RADAR_MSGS_MESSAGE_RLMONTXPHSHIFTREP_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace radar_msgs
{
template <class ContainerAllocator>
struct RlMonTxPhShiftRep_
{
  typedef RlMonTxPhShiftRep_<ContainerAllocator> Type;

  RlMonTxPhShiftRep_()
    : statusFlags(0)
    , errorCode(0)
    , profIndex(0)
    , reserved0(0)
    , reserved1(0)
    , phaseShifterMonVal1(0)
    , phaseShifterMonVal2(0)
    , phaseShifterMonVal3(0)
    , phaseShifterMonVal4(0)
    , txPsAmplitudeVal1(0)
    , txPsAmplitudeVal2(0)
    , txPsAmplitudeVal3(0)
    , txPsAmplitudeVal4(0)
    , txPsNoiseVal1(0)
    , txPsNoiseVal2(0)
    , txPsNoiseVal3(0)
    , txPsNoiseVal4(0)
    , timeStamp(0)
    , reserved2(0)
    , reserved3(0)  {
    }
  RlMonTxPhShiftRep_(const ContainerAllocator& _alloc)
    : statusFlags(0)
    , errorCode(0)
    , profIndex(0)
    , reserved0(0)
    , reserved1(0)
    , phaseShifterMonVal1(0)
    , phaseShifterMonVal2(0)
    , phaseShifterMonVal3(0)
    , phaseShifterMonVal4(0)
    , txPsAmplitudeVal1(0)
    , txPsAmplitudeVal2(0)
    , txPsAmplitudeVal3(0)
    , txPsAmplitudeVal4(0)
    , txPsNoiseVal1(0)
    , txPsNoiseVal2(0)
    , txPsNoiseVal3(0)
    , txPsNoiseVal4(0)
    , timeStamp(0)
    , reserved2(0)
    , reserved3(0)  {
  (void)_alloc;
    }



   typedef uint16_t _statusFlags_type;
  _statusFlags_type statusFlags;

   typedef uint16_t _errorCode_type;
  _errorCode_type errorCode;

   typedef uint8_t _profIndex_type;
  _profIndex_type profIndex;

   typedef uint8_t _reserved0_type;
  _reserved0_type reserved0;

   typedef uint16_t _reserved1_type;
  _reserved1_type reserved1;

   typedef uint16_t _phaseShifterMonVal1_type;
  _phaseShifterMonVal1_type phaseShifterMonVal1;

   typedef uint16_t _phaseShifterMonVal2_type;
  _phaseShifterMonVal2_type phaseShifterMonVal2;

   typedef uint16_t _phaseShifterMonVal3_type;
  _phaseShifterMonVal3_type phaseShifterMonVal3;

   typedef uint16_t _phaseShifterMonVal4_type;
  _phaseShifterMonVal4_type phaseShifterMonVal4;

   typedef int16_t _txPsAmplitudeVal1_type;
  _txPsAmplitudeVal1_type txPsAmplitudeVal1;

   typedef int16_t _txPsAmplitudeVal2_type;
  _txPsAmplitudeVal2_type txPsAmplitudeVal2;

   typedef int16_t _txPsAmplitudeVal3_type;
  _txPsAmplitudeVal3_type txPsAmplitudeVal3;

   typedef int16_t _txPsAmplitudeVal4_type;
  _txPsAmplitudeVal4_type txPsAmplitudeVal4;

   typedef int8_t _txPsNoiseVal1_type;
  _txPsNoiseVal1_type txPsNoiseVal1;

   typedef int8_t _txPsNoiseVal2_type;
  _txPsNoiseVal2_type txPsNoiseVal2;

   typedef int8_t _txPsNoiseVal3_type;
  _txPsNoiseVal3_type txPsNoiseVal3;

   typedef int8_t _txPsNoiseVal4_type;
  _txPsNoiseVal4_type txPsNoiseVal4;

   typedef uint32_t _timeStamp_type;
  _timeStamp_type timeStamp;

   typedef uint32_t _reserved2_type;
  _reserved2_type reserved2;

   typedef uint32_t _reserved3_type;
  _reserved3_type reserved3;





  typedef boost::shared_ptr< ::radar_msgs::RlMonTxPhShiftRep_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::radar_msgs::RlMonTxPhShiftRep_<ContainerAllocator> const> ConstPtr;

}; // struct RlMonTxPhShiftRep_

typedef ::radar_msgs::RlMonTxPhShiftRep_<std::allocator<void> > RlMonTxPhShiftRep;

typedef boost::shared_ptr< ::radar_msgs::RlMonTxPhShiftRep > RlMonTxPhShiftRepPtr;
typedef boost::shared_ptr< ::radar_msgs::RlMonTxPhShiftRep const> RlMonTxPhShiftRepConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::radar_msgs::RlMonTxPhShiftRep_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::radar_msgs::RlMonTxPhShiftRep_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::radar_msgs::RlMonTxPhShiftRep_<ContainerAllocator1> & lhs, const ::radar_msgs::RlMonTxPhShiftRep_<ContainerAllocator2> & rhs)
{
  return lhs.statusFlags == rhs.statusFlags &&
    lhs.errorCode == rhs.errorCode &&
    lhs.profIndex == rhs.profIndex &&
    lhs.reserved0 == rhs.reserved0 &&
    lhs.reserved1 == rhs.reserved1 &&
    lhs.phaseShifterMonVal1 == rhs.phaseShifterMonVal1 &&
    lhs.phaseShifterMonVal2 == rhs.phaseShifterMonVal2 &&
    lhs.phaseShifterMonVal3 == rhs.phaseShifterMonVal3 &&
    lhs.phaseShifterMonVal4 == rhs.phaseShifterMonVal4 &&
    lhs.txPsAmplitudeVal1 == rhs.txPsAmplitudeVal1 &&
    lhs.txPsAmplitudeVal2 == rhs.txPsAmplitudeVal2 &&
    lhs.txPsAmplitudeVal3 == rhs.txPsAmplitudeVal3 &&
    lhs.txPsAmplitudeVal4 == rhs.txPsAmplitudeVal4 &&
    lhs.txPsNoiseVal1 == rhs.txPsNoiseVal1 &&
    lhs.txPsNoiseVal2 == rhs.txPsNoiseVal2 &&
    lhs.txPsNoiseVal3 == rhs.txPsNoiseVal3 &&
    lhs.txPsNoiseVal4 == rhs.txPsNoiseVal4 &&
    lhs.timeStamp == rhs.timeStamp &&
    lhs.reserved2 == rhs.reserved2 &&
    lhs.reserved3 == rhs.reserved3;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::radar_msgs::RlMonTxPhShiftRep_<ContainerAllocator1> & lhs, const ::radar_msgs::RlMonTxPhShiftRep_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace radar_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::radar_msgs::RlMonTxPhShiftRep_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::radar_msgs::RlMonTxPhShiftRep_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::radar_msgs::RlMonTxPhShiftRep_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::radar_msgs::RlMonTxPhShiftRep_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::radar_msgs::RlMonTxPhShiftRep_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::radar_msgs::RlMonTxPhShiftRep_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::radar_msgs::RlMonTxPhShiftRep_<ContainerAllocator> >
{
  static const char* value()
  {
    return "c35e9ef88c30d781e09f2fb7d35ab829";
  }

  static const char* value(const ::radar_msgs::RlMonTxPhShiftRep_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xc35e9ef88c30d781ULL;
  static const uint64_t static_value2 = 0xe09f2fb7d35ab829ULL;
};

template<class ContainerAllocator>
struct DataType< ::radar_msgs::RlMonTxPhShiftRep_<ContainerAllocator> >
{
  static const char* value()
  {
    return "radar_msgs/RlMonTxPhShiftRep";
  }

  static const char* value(const ::radar_msgs::RlMonTxPhShiftRep_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::radar_msgs::RlMonTxPhShiftRep_<ContainerAllocator> >
{
  static const char* value()
  {
    return "uint16 statusFlags\n"
"uint16 errorCode\n"
"uint8 profIndex\n"
"uint8 reserved0\n"
"uint16 reserved1\n"
"uint16 phaseShifterMonVal1\n"
"uint16 phaseShifterMonVal2\n"
"uint16 phaseShifterMonVal3\n"
"uint16 phaseShifterMonVal4\n"
"int16 txPsAmplitudeVal1\n"
"int16 txPsAmplitudeVal2\n"
"int16 txPsAmplitudeVal3\n"
"int16 txPsAmplitudeVal4\n"
"int8 txPsNoiseVal1\n"
"int8 txPsNoiseVal2\n"
"int8 txPsNoiseVal3\n"
"int8 txPsNoiseVal4\n"
"uint32 timeStamp\n"
"uint32 reserved2\n"
"uint32 reserved3\n"
;
  }

  static const char* value(const ::radar_msgs::RlMonTxPhShiftRep_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::radar_msgs::RlMonTxPhShiftRep_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.statusFlags);
      stream.next(m.errorCode);
      stream.next(m.profIndex);
      stream.next(m.reserved0);
      stream.next(m.reserved1);
      stream.next(m.phaseShifterMonVal1);
      stream.next(m.phaseShifterMonVal2);
      stream.next(m.phaseShifterMonVal3);
      stream.next(m.phaseShifterMonVal4);
      stream.next(m.txPsAmplitudeVal1);
      stream.next(m.txPsAmplitudeVal2);
      stream.next(m.txPsAmplitudeVal3);
      stream.next(m.txPsAmplitudeVal4);
      stream.next(m.txPsNoiseVal1);
      stream.next(m.txPsNoiseVal2);
      stream.next(m.txPsNoiseVal3);
      stream.next(m.txPsNoiseVal4);
      stream.next(m.timeStamp);
      stream.next(m.reserved2);
      stream.next(m.reserved3);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct RlMonTxPhShiftRep_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::radar_msgs::RlMonTxPhShiftRep_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::radar_msgs::RlMonTxPhShiftRep_<ContainerAllocator>& v)
  {
    s << indent << "statusFlags: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.statusFlags);
    s << indent << "errorCode: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.errorCode);
    s << indent << "profIndex: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.profIndex);
    s << indent << "reserved0: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.reserved0);
    s << indent << "reserved1: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.reserved1);
    s << indent << "phaseShifterMonVal1: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.phaseShifterMonVal1);
    s << indent << "phaseShifterMonVal2: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.phaseShifterMonVal2);
    s << indent << "phaseShifterMonVal3: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.phaseShifterMonVal3);
    s << indent << "phaseShifterMonVal4: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.phaseShifterMonVal4);
    s << indent << "txPsAmplitudeVal1: ";
    Printer<int16_t>::stream(s, indent + "  ", v.txPsAmplitudeVal1);
    s << indent << "txPsAmplitudeVal2: ";
    Printer<int16_t>::stream(s, indent + "  ", v.txPsAmplitudeVal2);
    s << indent << "txPsAmplitudeVal3: ";
    Printer<int16_t>::stream(s, indent + "  ", v.txPsAmplitudeVal3);
    s << indent << "txPsAmplitudeVal4: ";
    Printer<int16_t>::stream(s, indent + "  ", v.txPsAmplitudeVal4);
    s << indent << "txPsNoiseVal1: ";
    Printer<int8_t>::stream(s, indent + "  ", v.txPsNoiseVal1);
    s << indent << "txPsNoiseVal2: ";
    Printer<int8_t>::stream(s, indent + "  ", v.txPsNoiseVal2);
    s << indent << "txPsNoiseVal3: ";
    Printer<int8_t>::stream(s, indent + "  ", v.txPsNoiseVal3);
    s << indent << "txPsNoiseVal4: ";
    Printer<int8_t>::stream(s, indent + "  ", v.txPsNoiseVal4);
    s << indent << "timeStamp: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.timeStamp);
    s << indent << "reserved2: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved2);
    s << indent << "reserved3: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved3);
  }
};

} // namespace message_operations
} // namespace ros

#endif // RADAR_MSGS_MESSAGE_RLMONTXPHSHIFTREP_H
