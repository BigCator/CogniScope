// Generated by gencpp from file radar_msgs/RdInfo.msg
// DO NOT EDIT!


#ifndef RADAR_MSGS_MESSAGE_RDINFO_H
#define RADAR_MSGS_MESSAGE_RDINFO_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace radar_msgs
{
template <class ContainerAllocator>
struct RdInfo_
{
  typedef RdInfo_<ContainerAllocator> Type;

  RdInfo_()
    : header()
    , frameID(0)
    , cfarCount(0)
    , targetNum(0)
    , resetcnt(0)
    , objNum(0)
    , carSpeed(0.0)
    , carYawRate(0.0)
    , gearState(0)
    , odTimeoutCnt(0)
    , comProtV_I(0)
    , comProtV_II(0)
    , frameLostCnt(0)
    , beforeAdcErrCnt(0)
    , afterAdcErrCnt(0)
    , udpFrameLostCnt(0)
    , udpFreq(0.0)
    , timeSyncStatus(0)
    , velEstimate(0.0)
    , gndK(0.0)
    , gndB(0.0)
    , pcl_time(0.0)
    , od_time(0.0)
    , RdFrameLostCnt(0)  {
    }
  RdInfo_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , frameID(0)
    , cfarCount(0)
    , targetNum(0)
    , resetcnt(0)
    , objNum(0)
    , carSpeed(0.0)
    , carYawRate(0.0)
    , gearState(0)
    , odTimeoutCnt(0)
    , comProtV_I(0)
    , comProtV_II(0)
    , frameLostCnt(0)
    , beforeAdcErrCnt(0)
    , afterAdcErrCnt(0)
    , udpFrameLostCnt(0)
    , udpFreq(0.0)
    , timeSyncStatus(0)
    , velEstimate(0.0)
    , gndK(0.0)
    , gndB(0.0)
    , pcl_time(0.0)
    , od_time(0.0)
    , RdFrameLostCnt(0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef uint32_t _frameID_type;
  _frameID_type frameID;

   typedef uint32_t _cfarCount_type;
  _cfarCount_type cfarCount;

   typedef uint32_t _targetNum_type;
  _targetNum_type targetNum;

   typedef int16_t _resetcnt_type;
  _resetcnt_type resetcnt;

   typedef uint32_t _objNum_type;
  _objNum_type objNum;

   typedef float _carSpeed_type;
  _carSpeed_type carSpeed;

   typedef float _carYawRate_type;
  _carYawRate_type carYawRate;

   typedef uint16_t _gearState_type;
  _gearState_type gearState;

   typedef int16_t _odTimeoutCnt_type;
  _odTimeoutCnt_type odTimeoutCnt;

   typedef uint16_t _comProtV_I_type;
  _comProtV_I_type comProtV_I;

   typedef uint16_t _comProtV_II_type;
  _comProtV_II_type comProtV_II;

   typedef uint16_t _frameLostCnt_type;
  _frameLostCnt_type frameLostCnt;

   typedef uint16_t _beforeAdcErrCnt_type;
  _beforeAdcErrCnt_type beforeAdcErrCnt;

   typedef uint16_t _afterAdcErrCnt_type;
  _afterAdcErrCnt_type afterAdcErrCnt;

   typedef uint32_t _udpFrameLostCnt_type;
  _udpFrameLostCnt_type udpFrameLostCnt;

   typedef float _udpFreq_type;
  _udpFreq_type udpFreq;

   typedef uint16_t _timeSyncStatus_type;
  _timeSyncStatus_type timeSyncStatus;

   typedef float _velEstimate_type;
  _velEstimate_type velEstimate;

   typedef float _gndK_type;
  _gndK_type gndK;

   typedef float _gndB_type;
  _gndB_type gndB;

   typedef float _pcl_time_type;
  _pcl_time_type pcl_time;

   typedef float _od_time_type;
  _od_time_type od_time;

   typedef uint32_t _RdFrameLostCnt_type;
  _RdFrameLostCnt_type RdFrameLostCnt;





  typedef boost::shared_ptr< ::radar_msgs::RdInfo_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::radar_msgs::RdInfo_<ContainerAllocator> const> ConstPtr;

}; // struct RdInfo_

typedef ::radar_msgs::RdInfo_<std::allocator<void> > RdInfo;

typedef boost::shared_ptr< ::radar_msgs::RdInfo > RdInfoPtr;
typedef boost::shared_ptr< ::radar_msgs::RdInfo const> RdInfoConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::radar_msgs::RdInfo_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::radar_msgs::RdInfo_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::radar_msgs::RdInfo_<ContainerAllocator1> & lhs, const ::radar_msgs::RdInfo_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.frameID == rhs.frameID &&
    lhs.cfarCount == rhs.cfarCount &&
    lhs.targetNum == rhs.targetNum &&
    lhs.resetcnt == rhs.resetcnt &&
    lhs.objNum == rhs.objNum &&
    lhs.carSpeed == rhs.carSpeed &&
    lhs.carYawRate == rhs.carYawRate &&
    lhs.gearState == rhs.gearState &&
    lhs.odTimeoutCnt == rhs.odTimeoutCnt &&
    lhs.comProtV_I == rhs.comProtV_I &&
    lhs.comProtV_II == rhs.comProtV_II &&
    lhs.frameLostCnt == rhs.frameLostCnt &&
    lhs.beforeAdcErrCnt == rhs.beforeAdcErrCnt &&
    lhs.afterAdcErrCnt == rhs.afterAdcErrCnt &&
    lhs.udpFrameLostCnt == rhs.udpFrameLostCnt &&
    lhs.udpFreq == rhs.udpFreq &&
    lhs.timeSyncStatus == rhs.timeSyncStatus &&
    lhs.velEstimate == rhs.velEstimate &&
    lhs.gndK == rhs.gndK &&
    lhs.gndB == rhs.gndB &&
    lhs.pcl_time == rhs.pcl_time &&
    lhs.od_time == rhs.od_time &&
    lhs.RdFrameLostCnt == rhs.RdFrameLostCnt;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::radar_msgs::RdInfo_<ContainerAllocator1> & lhs, const ::radar_msgs::RdInfo_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace radar_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::radar_msgs::RdInfo_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::radar_msgs::RdInfo_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::radar_msgs::RdInfo_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::radar_msgs::RdInfo_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::radar_msgs::RdInfo_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::radar_msgs::RdInfo_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::radar_msgs::RdInfo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "990a952bd164911e0965074cc0babe8d";
  }

  static const char* value(const ::radar_msgs::RdInfo_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x990a952bd164911eULL;
  static const uint64_t static_value2 = 0x0965074cc0babe8dULL;
};

template<class ContainerAllocator>
struct DataType< ::radar_msgs::RdInfo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "radar_msgs/RdInfo";
  }

  static const char* value(const ::radar_msgs::RdInfo_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::radar_msgs::RdInfo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header  header              # Includes measurement timestamp and coordinate frame.\n"
"uint32  frameID\n"
"uint32  cfarCount           # cfar count\n"
"uint32  targetNum           # targets Num\n"
"int16   resetcnt            # reset count\n"
"uint32  objNum              # object number of this frame\n"
"float32 carSpeed            # ego car speed\n"
"float32 carYawRate          # ego car yaw rate\n"
"uint16  gearState           # ego car gear state\n"
"int16   odTimeoutCnt\n"
"uint16  comProtV_I\n"
"uint16  comProtV_II\n"
"uint16  frameLostCnt        # frame lost count checked by ROS sw\n"
"uint16  beforeAdcErrCnt\n"
"uint16  afterAdcErrCnt\n"
"uint32  udpFrameLostCnt     # counter of lost frames\n"
"float32 udpFreq             # frames frequency in Hz\n"
"uint16  timeSyncStatus      # status of time synchronization\n"
"float32 velEstimate         # estimated car speed, m/s\n"
"float32 gndK\n"
"float32 gndB\n"
"float32 pcl_time            # duration of od process (ms)\n"
"float32 od_time             # duration of od process (ms)\n"
"uint32  RdFrameLostCnt      # frame lost count in radar\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::radar_msgs::RdInfo_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::radar_msgs::RdInfo_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.frameID);
      stream.next(m.cfarCount);
      stream.next(m.targetNum);
      stream.next(m.resetcnt);
      stream.next(m.objNum);
      stream.next(m.carSpeed);
      stream.next(m.carYawRate);
      stream.next(m.gearState);
      stream.next(m.odTimeoutCnt);
      stream.next(m.comProtV_I);
      stream.next(m.comProtV_II);
      stream.next(m.frameLostCnt);
      stream.next(m.beforeAdcErrCnt);
      stream.next(m.afterAdcErrCnt);
      stream.next(m.udpFrameLostCnt);
      stream.next(m.udpFreq);
      stream.next(m.timeSyncStatus);
      stream.next(m.velEstimate);
      stream.next(m.gndK);
      stream.next(m.gndB);
      stream.next(m.pcl_time);
      stream.next(m.od_time);
      stream.next(m.RdFrameLostCnt);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct RdInfo_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::radar_msgs::RdInfo_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::radar_msgs::RdInfo_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "frameID: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.frameID);
    s << indent << "cfarCount: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.cfarCount);
    s << indent << "targetNum: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.targetNum);
    s << indent << "resetcnt: ";
    Printer<int16_t>::stream(s, indent + "  ", v.resetcnt);
    s << indent << "objNum: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.objNum);
    s << indent << "carSpeed: ";
    Printer<float>::stream(s, indent + "  ", v.carSpeed);
    s << indent << "carYawRate: ";
    Printer<float>::stream(s, indent + "  ", v.carYawRate);
    s << indent << "gearState: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.gearState);
    s << indent << "odTimeoutCnt: ";
    Printer<int16_t>::stream(s, indent + "  ", v.odTimeoutCnt);
    s << indent << "comProtV_I: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.comProtV_I);
    s << indent << "comProtV_II: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.comProtV_II);
    s << indent << "frameLostCnt: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.frameLostCnt);
    s << indent << "beforeAdcErrCnt: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.beforeAdcErrCnt);
    s << indent << "afterAdcErrCnt: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.afterAdcErrCnt);
    s << indent << "udpFrameLostCnt: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.udpFrameLostCnt);
    s << indent << "udpFreq: ";
    Printer<float>::stream(s, indent + "  ", v.udpFreq);
    s << indent << "timeSyncStatus: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.timeSyncStatus);
    s << indent << "velEstimate: ";
    Printer<float>::stream(s, indent + "  ", v.velEstimate);
    s << indent << "gndK: ";
    Printer<float>::stream(s, indent + "  ", v.gndK);
    s << indent << "gndB: ";
    Printer<float>::stream(s, indent + "  ", v.gndB);
    s << indent << "pcl_time: ";
    Printer<float>::stream(s, indent + "  ", v.pcl_time);
    s << indent << "od_time: ";
    Printer<float>::stream(s, indent + "  ", v.od_time);
    s << indent << "RdFrameLostCnt: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.RdFrameLostCnt);
  }
};

} // namespace message_operations
} // namespace ros

#endif // RADAR_MSGS_MESSAGE_RDINFO_H
