// Generated by gencpp from file radar_msgs/RlMonSynthFreqNonLiveRep.msg
// DO NOT EDIT!


#ifndef RADAR_MSGS_MESSAGE_RLMONSYNTHFREQNONLIVEREP_H
#define RADAR_MSGS_MESSAGE_RLMONSYNTHFREQNONLIVEREP_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace radar_msgs
{
template <class ContainerAllocator>
struct RlMonSynthFreqNonLiveRep_
{
  typedef RlMonSynthFreqNonLiveRep_<ContainerAllocator> Type;

  RlMonSynthFreqNonLiveRep_()
    : statusFlags(0)
    , errorCode(0)
    , profIndex0(0)
    , reserved0(0)
    , reserved1(0)
    , maxFreqErVal0(0)
    , freqFailCnt0(0)
    , maxFreqFailTime0(0)
    , reserved2(0)
    , profIndex1(0)
    , reserved3(0)
    , reserved4(0)
    , maxFreqErVal1(0)
    , freqFailCnt1(0)
    , maxFreqFailTime1(0)
    , reserved5(0)
    , timeStamp(0)  {
    }
  RlMonSynthFreqNonLiveRep_(const ContainerAllocator& _alloc)
    : statusFlags(0)
    , errorCode(0)
    , profIndex0(0)
    , reserved0(0)
    , reserved1(0)
    , maxFreqErVal0(0)
    , freqFailCnt0(0)
    , maxFreqFailTime0(0)
    , reserved2(0)
    , profIndex1(0)
    , reserved3(0)
    , reserved4(0)
    , maxFreqErVal1(0)
    , freqFailCnt1(0)
    , maxFreqFailTime1(0)
    , reserved5(0)
    , timeStamp(0)  {
  (void)_alloc;
    }



   typedef uint16_t _statusFlags_type;
  _statusFlags_type statusFlags;

   typedef uint16_t _errorCode_type;
  _errorCode_type errorCode;

   typedef uint8_t _profIndex0_type;
  _profIndex0_type profIndex0;

   typedef uint8_t _reserved0_type;
  _reserved0_type reserved0;

   typedef uint16_t _reserved1_type;
  _reserved1_type reserved1;

   typedef int32_t _maxFreqErVal0_type;
  _maxFreqErVal0_type maxFreqErVal0;

   typedef uint32_t _freqFailCnt0_type;
  _freqFailCnt0_type freqFailCnt0;

   typedef uint32_t _maxFreqFailTime0_type;
  _maxFreqFailTime0_type maxFreqFailTime0;

   typedef uint32_t _reserved2_type;
  _reserved2_type reserved2;

   typedef uint8_t _profIndex1_type;
  _profIndex1_type profIndex1;

   typedef uint8_t _reserved3_type;
  _reserved3_type reserved3;

   typedef uint16_t _reserved4_type;
  _reserved4_type reserved4;

   typedef int32_t _maxFreqErVal1_type;
  _maxFreqErVal1_type maxFreqErVal1;

   typedef uint32_t _freqFailCnt1_type;
  _freqFailCnt1_type freqFailCnt1;

   typedef uint32_t _maxFreqFailTime1_type;
  _maxFreqFailTime1_type maxFreqFailTime1;

   typedef uint32_t _reserved5_type;
  _reserved5_type reserved5;

   typedef uint32_t _timeStamp_type;
  _timeStamp_type timeStamp;





  typedef boost::shared_ptr< ::radar_msgs::RlMonSynthFreqNonLiveRep_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::radar_msgs::RlMonSynthFreqNonLiveRep_<ContainerAllocator> const> ConstPtr;

}; // struct RlMonSynthFreqNonLiveRep_

typedef ::radar_msgs::RlMonSynthFreqNonLiveRep_<std::allocator<void> > RlMonSynthFreqNonLiveRep;

typedef boost::shared_ptr< ::radar_msgs::RlMonSynthFreqNonLiveRep > RlMonSynthFreqNonLiveRepPtr;
typedef boost::shared_ptr< ::radar_msgs::RlMonSynthFreqNonLiveRep const> RlMonSynthFreqNonLiveRepConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::radar_msgs::RlMonSynthFreqNonLiveRep_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::radar_msgs::RlMonSynthFreqNonLiveRep_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::radar_msgs::RlMonSynthFreqNonLiveRep_<ContainerAllocator1> & lhs, const ::radar_msgs::RlMonSynthFreqNonLiveRep_<ContainerAllocator2> & rhs)
{
  return lhs.statusFlags == rhs.statusFlags &&
    lhs.errorCode == rhs.errorCode &&
    lhs.profIndex0 == rhs.profIndex0 &&
    lhs.reserved0 == rhs.reserved0 &&
    lhs.reserved1 == rhs.reserved1 &&
    lhs.maxFreqErVal0 == rhs.maxFreqErVal0 &&
    lhs.freqFailCnt0 == rhs.freqFailCnt0 &&
    lhs.maxFreqFailTime0 == rhs.maxFreqFailTime0 &&
    lhs.reserved2 == rhs.reserved2 &&
    lhs.profIndex1 == rhs.profIndex1 &&
    lhs.reserved3 == rhs.reserved3 &&
    lhs.reserved4 == rhs.reserved4 &&
    lhs.maxFreqErVal1 == rhs.maxFreqErVal1 &&
    lhs.freqFailCnt1 == rhs.freqFailCnt1 &&
    lhs.maxFreqFailTime1 == rhs.maxFreqFailTime1 &&
    lhs.reserved5 == rhs.reserved5 &&
    lhs.timeStamp == rhs.timeStamp;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::radar_msgs::RlMonSynthFreqNonLiveRep_<ContainerAllocator1> & lhs, const ::radar_msgs::RlMonSynthFreqNonLiveRep_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace radar_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::radar_msgs::RlMonSynthFreqNonLiveRep_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::radar_msgs::RlMonSynthFreqNonLiveRep_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::radar_msgs::RlMonSynthFreqNonLiveRep_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::radar_msgs::RlMonSynthFreqNonLiveRep_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::radar_msgs::RlMonSynthFreqNonLiveRep_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::radar_msgs::RlMonSynthFreqNonLiveRep_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::radar_msgs::RlMonSynthFreqNonLiveRep_<ContainerAllocator> >
{
  static const char* value()
  {
    return "d0edbc23d8d4e3fb8b9ba98fa67b4c6d";
  }

  static const char* value(const ::radar_msgs::RlMonSynthFreqNonLiveRep_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xd0edbc23d8d4e3fbULL;
  static const uint64_t static_value2 = 0x8b9ba98fa67b4c6dULL;
};

template<class ContainerAllocator>
struct DataType< ::radar_msgs::RlMonSynthFreqNonLiveRep_<ContainerAllocator> >
{
  static const char* value()
  {
    return "radar_msgs/RlMonSynthFreqNonLiveRep";
  }

  static const char* value(const ::radar_msgs::RlMonSynthFreqNonLiveRep_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::radar_msgs::RlMonSynthFreqNonLiveRep_<ContainerAllocator> >
{
  static const char* value()
  {
    return "uint16 statusFlags\n"
"uint16 errorCode\n"
"uint8 profIndex0\n"
"uint8 reserved0\n"
"uint16 reserved1\n"
"int32 maxFreqErVal0\n"
"uint32 freqFailCnt0\n"
"uint32 maxFreqFailTime0\n"
"uint32 reserved2\n"
"uint8 profIndex1\n"
"uint8 reserved3\n"
"uint16 reserved4\n"
"int32 maxFreqErVal1\n"
"uint32 freqFailCnt1\n"
"uint32 maxFreqFailTime1\n"
"uint32 reserved5\n"
"uint32 timeStamp\n"
;
  }

  static const char* value(const ::radar_msgs::RlMonSynthFreqNonLiveRep_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::radar_msgs::RlMonSynthFreqNonLiveRep_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.statusFlags);
      stream.next(m.errorCode);
      stream.next(m.profIndex0);
      stream.next(m.reserved0);
      stream.next(m.reserved1);
      stream.next(m.maxFreqErVal0);
      stream.next(m.freqFailCnt0);
      stream.next(m.maxFreqFailTime0);
      stream.next(m.reserved2);
      stream.next(m.profIndex1);
      stream.next(m.reserved3);
      stream.next(m.reserved4);
      stream.next(m.maxFreqErVal1);
      stream.next(m.freqFailCnt1);
      stream.next(m.maxFreqFailTime1);
      stream.next(m.reserved5);
      stream.next(m.timeStamp);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct RlMonSynthFreqNonLiveRep_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::radar_msgs::RlMonSynthFreqNonLiveRep_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::radar_msgs::RlMonSynthFreqNonLiveRep_<ContainerAllocator>& v)
  {
    s << indent << "statusFlags: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.statusFlags);
    s << indent << "errorCode: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.errorCode);
    s << indent << "profIndex0: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.profIndex0);
    s << indent << "reserved0: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.reserved0);
    s << indent << "reserved1: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.reserved1);
    s << indent << "maxFreqErVal0: ";
    Printer<int32_t>::stream(s, indent + "  ", v.maxFreqErVal0);
    s << indent << "freqFailCnt0: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.freqFailCnt0);
    s << indent << "maxFreqFailTime0: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.maxFreqFailTime0);
    s << indent << "reserved2: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved2);
    s << indent << "profIndex1: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.profIndex1);
    s << indent << "reserved3: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.reserved3);
    s << indent << "reserved4: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.reserved4);
    s << indent << "maxFreqErVal1: ";
    Printer<int32_t>::stream(s, indent + "  ", v.maxFreqErVal1);
    s << indent << "freqFailCnt1: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.freqFailCnt1);
    s << indent << "maxFreqFailTime1: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.maxFreqFailTime1);
    s << indent << "reserved5: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved5);
    s << indent << "timeStamp: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.timeStamp);
  }
};

} // namespace message_operations
} // namespace ros

#endif // RADAR_MSGS_MESSAGE_RLMONSYNTHFREQNONLIVEREP_H
