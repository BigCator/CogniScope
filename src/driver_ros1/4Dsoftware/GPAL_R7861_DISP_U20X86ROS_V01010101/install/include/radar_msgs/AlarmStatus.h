// Generated by gencpp from file radar_msgs/AlarmStatus.msg
// DO NOT EDIT!


#ifndef RADAR_MSGS_MESSAGE_ALARMSTATUS_H
#define RADAR_MSGS_MESSAGE_ALARMSTATUS_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace radar_msgs
{
template <class ContainerAllocator>
struct AlarmStatus_
{
  typedef AlarmStatus_<ContainerAllocator> Type;

  AlarmStatus_()
    : header()
    , radarID(0)
    , frameCnt(0)
    , alarmNum(0)
    , alarmCode01(0)
    , alarmCode02(0)
    , alarmCode03(0)
    , alarmCode04(0)
    , alarmCode05(0)
    , alarmCode06(0)
    , alarmCode07(0)
    , alarmCode08(0)
    , alarmCode09(0)
    , alarmCode10(0)
    , alarmCode11(0)
    , alarmCode12(0)
    , alarmCode13(0)
    , alarmCode14(0)
    , alarmCode15(0)
    , alarmCode16(0)
    , alarmCode17(0)
    , alarmCode18(0)
    , alarmCode19(0)
    , alarmCode20(0)  {
    }
  AlarmStatus_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , radarID(0)
    , frameCnt(0)
    , alarmNum(0)
    , alarmCode01(0)
    , alarmCode02(0)
    , alarmCode03(0)
    , alarmCode04(0)
    , alarmCode05(0)
    , alarmCode06(0)
    , alarmCode07(0)
    , alarmCode08(0)
    , alarmCode09(0)
    , alarmCode10(0)
    , alarmCode11(0)
    , alarmCode12(0)
    , alarmCode13(0)
    , alarmCode14(0)
    , alarmCode15(0)
    , alarmCode16(0)
    , alarmCode17(0)
    , alarmCode18(0)
    , alarmCode19(0)
    , alarmCode20(0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef uint32_t _radarID_type;
  _radarID_type radarID;

   typedef uint32_t _frameCnt_type;
  _frameCnt_type frameCnt;

   typedef uint32_t _alarmNum_type;
  _alarmNum_type alarmNum;

   typedef uint16_t _alarmCode01_type;
  _alarmCode01_type alarmCode01;

   typedef uint16_t _alarmCode02_type;
  _alarmCode02_type alarmCode02;

   typedef uint16_t _alarmCode03_type;
  _alarmCode03_type alarmCode03;

   typedef uint16_t _alarmCode04_type;
  _alarmCode04_type alarmCode04;

   typedef uint16_t _alarmCode05_type;
  _alarmCode05_type alarmCode05;

   typedef uint16_t _alarmCode06_type;
  _alarmCode06_type alarmCode06;

   typedef uint16_t _alarmCode07_type;
  _alarmCode07_type alarmCode07;

   typedef uint16_t _alarmCode08_type;
  _alarmCode08_type alarmCode08;

   typedef uint16_t _alarmCode09_type;
  _alarmCode09_type alarmCode09;

   typedef uint16_t _alarmCode10_type;
  _alarmCode10_type alarmCode10;

   typedef uint16_t _alarmCode11_type;
  _alarmCode11_type alarmCode11;

   typedef uint16_t _alarmCode12_type;
  _alarmCode12_type alarmCode12;

   typedef uint16_t _alarmCode13_type;
  _alarmCode13_type alarmCode13;

   typedef uint16_t _alarmCode14_type;
  _alarmCode14_type alarmCode14;

   typedef uint16_t _alarmCode15_type;
  _alarmCode15_type alarmCode15;

   typedef uint16_t _alarmCode16_type;
  _alarmCode16_type alarmCode16;

   typedef uint16_t _alarmCode17_type;
  _alarmCode17_type alarmCode17;

   typedef uint16_t _alarmCode18_type;
  _alarmCode18_type alarmCode18;

   typedef uint16_t _alarmCode19_type;
  _alarmCode19_type alarmCode19;

   typedef uint16_t _alarmCode20_type;
  _alarmCode20_type alarmCode20;





  typedef boost::shared_ptr< ::radar_msgs::AlarmStatus_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::radar_msgs::AlarmStatus_<ContainerAllocator> const> ConstPtr;

}; // struct AlarmStatus_

typedef ::radar_msgs::AlarmStatus_<std::allocator<void> > AlarmStatus;

typedef boost::shared_ptr< ::radar_msgs::AlarmStatus > AlarmStatusPtr;
typedef boost::shared_ptr< ::radar_msgs::AlarmStatus const> AlarmStatusConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::radar_msgs::AlarmStatus_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::radar_msgs::AlarmStatus_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::radar_msgs::AlarmStatus_<ContainerAllocator1> & lhs, const ::radar_msgs::AlarmStatus_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.radarID == rhs.radarID &&
    lhs.frameCnt == rhs.frameCnt &&
    lhs.alarmNum == rhs.alarmNum &&
    lhs.alarmCode01 == rhs.alarmCode01 &&
    lhs.alarmCode02 == rhs.alarmCode02 &&
    lhs.alarmCode03 == rhs.alarmCode03 &&
    lhs.alarmCode04 == rhs.alarmCode04 &&
    lhs.alarmCode05 == rhs.alarmCode05 &&
    lhs.alarmCode06 == rhs.alarmCode06 &&
    lhs.alarmCode07 == rhs.alarmCode07 &&
    lhs.alarmCode08 == rhs.alarmCode08 &&
    lhs.alarmCode09 == rhs.alarmCode09 &&
    lhs.alarmCode10 == rhs.alarmCode10 &&
    lhs.alarmCode11 == rhs.alarmCode11 &&
    lhs.alarmCode12 == rhs.alarmCode12 &&
    lhs.alarmCode13 == rhs.alarmCode13 &&
    lhs.alarmCode14 == rhs.alarmCode14 &&
    lhs.alarmCode15 == rhs.alarmCode15 &&
    lhs.alarmCode16 == rhs.alarmCode16 &&
    lhs.alarmCode17 == rhs.alarmCode17 &&
    lhs.alarmCode18 == rhs.alarmCode18 &&
    lhs.alarmCode19 == rhs.alarmCode19 &&
    lhs.alarmCode20 == rhs.alarmCode20;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::radar_msgs::AlarmStatus_<ContainerAllocator1> & lhs, const ::radar_msgs::AlarmStatus_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace radar_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::radar_msgs::AlarmStatus_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::radar_msgs::AlarmStatus_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::radar_msgs::AlarmStatus_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::radar_msgs::AlarmStatus_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::radar_msgs::AlarmStatus_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::radar_msgs::AlarmStatus_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::radar_msgs::AlarmStatus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "7c014f54c8b482dfb210caece3475030";
  }

  static const char* value(const ::radar_msgs::AlarmStatus_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x7c014f54c8b482dfULL;
  static const uint64_t static_value2 = 0xb210caece3475030ULL;
};

template<class ContainerAllocator>
struct DataType< ::radar_msgs::AlarmStatus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "radar_msgs/AlarmStatus";
  }

  static const char* value(const ::radar_msgs::AlarmStatus_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::radar_msgs::AlarmStatus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header                   # Includes measurement timestamp and coordinate frame.\n"
"uint32 radarID                  # radar ID\n"
"uint32 frameCnt                 # frame cnt in radar\n"
"uint32 alarmNum                 # number of alarm\n"
"uint16 alarmCode01\n"
"uint16 alarmCode02\n"
"uint16 alarmCode03\n"
"uint16 alarmCode04\n"
"uint16 alarmCode05\n"
"uint16 alarmCode06\n"
"uint16 alarmCode07\n"
"uint16 alarmCode08\n"
"uint16 alarmCode09\n"
"uint16 alarmCode10\n"
"uint16 alarmCode11\n"
"uint16 alarmCode12\n"
"uint16 alarmCode13\n"
"uint16 alarmCode14\n"
"uint16 alarmCode15\n"
"uint16 alarmCode16\n"
"uint16 alarmCode17\n"
"uint16 alarmCode18\n"
"uint16 alarmCode19\n"
"uint16 alarmCode20\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::radar_msgs::AlarmStatus_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::radar_msgs::AlarmStatus_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.radarID);
      stream.next(m.frameCnt);
      stream.next(m.alarmNum);
      stream.next(m.alarmCode01);
      stream.next(m.alarmCode02);
      stream.next(m.alarmCode03);
      stream.next(m.alarmCode04);
      stream.next(m.alarmCode05);
      stream.next(m.alarmCode06);
      stream.next(m.alarmCode07);
      stream.next(m.alarmCode08);
      stream.next(m.alarmCode09);
      stream.next(m.alarmCode10);
      stream.next(m.alarmCode11);
      stream.next(m.alarmCode12);
      stream.next(m.alarmCode13);
      stream.next(m.alarmCode14);
      stream.next(m.alarmCode15);
      stream.next(m.alarmCode16);
      stream.next(m.alarmCode17);
      stream.next(m.alarmCode18);
      stream.next(m.alarmCode19);
      stream.next(m.alarmCode20);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct AlarmStatus_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::radar_msgs::AlarmStatus_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::radar_msgs::AlarmStatus_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "radarID: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.radarID);
    s << indent << "frameCnt: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.frameCnt);
    s << indent << "alarmNum: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.alarmNum);
    s << indent << "alarmCode01: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.alarmCode01);
    s << indent << "alarmCode02: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.alarmCode02);
    s << indent << "alarmCode03: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.alarmCode03);
    s << indent << "alarmCode04: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.alarmCode04);
    s << indent << "alarmCode05: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.alarmCode05);
    s << indent << "alarmCode06: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.alarmCode06);
    s << indent << "alarmCode07: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.alarmCode07);
    s << indent << "alarmCode08: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.alarmCode08);
    s << indent << "alarmCode09: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.alarmCode09);
    s << indent << "alarmCode10: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.alarmCode10);
    s << indent << "alarmCode11: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.alarmCode11);
    s << indent << "alarmCode12: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.alarmCode12);
    s << indent << "alarmCode13: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.alarmCode13);
    s << indent << "alarmCode14: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.alarmCode14);
    s << indent << "alarmCode15: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.alarmCode15);
    s << indent << "alarmCode16: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.alarmCode16);
    s << indent << "alarmCode17: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.alarmCode17);
    s << indent << "alarmCode18: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.alarmCode18);
    s << indent << "alarmCode19: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.alarmCode19);
    s << indent << "alarmCode20: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.alarmCode20);
  }
};

} // namespace message_operations
} // namespace ros

#endif // RADAR_MSGS_MESSAGE_ALARMSTATUS_H
