# Copyright 2013 Velodyne Acoustics, Inc.
# Copyright 2017 Robosense.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import csv
import datetime
import time
import math
import paraview.simple as smp
from paraview import servermanager
from paraview import vtk

import PythonQt
from PythonQt import QtCore, QtGui

from vtkIOXMLPython import vtkXMLPolyDataWriter
import kiwiviewerExporter
import gridAdjustmentDialog
import planefit

from PythonQt.paraview import vvCalibrationDialog, vvCropReturnsDialog, vvSelectFramesDialog, vvConnectInformationDialog, \
                              vvNetworkConfigSensorDialog, vvNetworkConfigPcapDialog, vvLaserSelectionDialog, vvPointsSelectionDialog
from RSlidar16PluginPython import vtkRSlidar16Reader

_repCache = {}

SAMPLE_PROCESSING_MODE = False

def cachedGetRepresentation(src, view):
    try:
        return _repCache[(src, view)]
    except KeyError:
        rep = smp.GetRepresentation(src, view)
        _repCache[(src, view)] = rep
        return rep

class AppLogic(object):

    def __init__(self):
        self.playing = False
        self.playDirection = 1
        self.seekPlayDirection = 1
        self.seekPlay = False
        self.targetFps = 10 #30
        self.renderIsPending = False
        self.createStatusBarWidgets()
        self.setupTimers()

        self.mousePressed = False

        mainView = smp.GetActiveView()
        views = smp.GetRenderViews()
        otherViews = [v for v in views if v != mainView]
        assert len(otherViews) == 1
        overheadView = otherViews[0]
        self.mainView = mainView
        self.overheadView = overheadView

        self.transformMode = 0
        self.relativeTransform = False

        self.reader = None
        self.position = (None, None, None)
        self.sensor = None

        self.csvfiledircent = "./"
        self.fps = [0,0]

        self.zhenlv = 0
        self.zhenlv_cur = 0
        self.zhenlv_jishu = 0

        self.pointSize = 2
        self.numberOfTrailingFrames = 0

        print "finish initialization!"

    def setupTimers(self):
        self.playTimer = QtCore.QTimer()
        self.playTimer.setSingleShot(True)
        self.playTimer.connect('timeout()', onPlayTimer)

        self.seekTimer = QtCore.QTimer()
        self.seekTimer.setSingleShot(True)
        self.seekTimer.connect('timeout()', seekPressTimeout)

        self.renderTimer = QtCore.QTimer()
        self.renderTimer.setSingleShot(True)
        self.renderTimer.connect('timeout()', forceRender)

        self.tempTimer = QtCore.QTimer()
        self.tempTimer.setSingleShot(True)
        self.tempTimer.connect('timeout()', outputTempTimer)

    def createStatusBarWidgets(self):

        self.logoLabel = QtGui.QLabel()
        self.logoLabel.setPixmap(QtGui.QPixmap(":/RSlidar16Plugin/rslidar_logo.png"))
        self.logoLabel.setScaledContents(True)

        self.lidarTypeLabel = QtGui.QLabel()
        self.filenameLabel = QtGui.QLabel()
        self.timeLabel = QtGui.QLabel()
        self.localTime = QtGui.QLabel()
        self.framerate = QtGui.QLabel()
        self.tempLabel = QtGui.QLabel()
        self.statusLabel = QtGui.QLabel()

class IconPaths(object):

    trailingFrames = ':/RSlidar16Plugin/trailingframes.png'
    play = ':/RSlidar16Plugin/media-playback-start.png'
    pause =':/RSlidar16Plugin/media-playback-pause.png'
    seekForward = ':/RSlidar16Plugin/media-seek-forward.png'
    seekForward2x = ':/RSlidar16Plugin/media-seek-forward-2x.png'
    seekForwardHalfx = ':/RSlidar16Plugin/media-seek-forward-0.5x.png'
    seekForwardQuarterx = ':/RSlidar16Plugin/media-seek-forward-0.25x.png'
    seekForward3x = ':/RSlidar16Plugin/media-seek-forward-3x.png'
    seekBackward = ':/RSlidar16Plugin/media-seek-backward.png'
    seekBackward1x = ':/RSlidar16Plugin/media-seek-backward-1x.png'
    seekBackward2x = ':/RSlidar16Plugin/media-seek-backward-2x.png'
    seekBackward3x = ':/RSlidar16Plugin/media-seek-backward-3x.png'
    seekBackwardHalfx = ':/RSlidar16Plugin/media-seek-backward-0.5x.png'
    seekBackwardQuarterx = ':/RSlidar16Plugin/media-seek-backward-0.25x.png'


def hasArrayName(sourceProxy, arrayName):
    '''
    Returns True if the data has non-zero points and has a point data
    attribute with the given arrayName.
    '''
    info = sourceProxy.GetDataInformation().DataInformation

    if info.GetNumberOfPoints() == 0:
        return False

    info = info.GetAttributeInformation(0)
    for i in xrange(info.GetNumberOfArrays()):
        if info.GetArrayInformation(i).GetName() == arrayName:
            return True
    return False


def openData(filename):

    close()

    reader = smp.OpenDataFile(filename, guiName='Data')

    if not reader:
        return

    rep = smp.Show(reader)
    rep.InterpolateScalarsBeforeMapping = 0
    setDefaultLookupTables(reader)
    colorByIntensity(reader)

    showSourceInSpreadSheet(reader)

    smp.GetActiveView().ViewTime = 0.0

    app.reader = reader
    app.filenameLabel.setText('File: %s' % os.path.basename(filename))

    updateSliderTimeRange()
    enablePlaybackActions()
    enableSaveActions()
    addRecentFile(filename)
    app.actions['actionSavePCAP'].setEnabled(False)
    app.actions['actionCropReturns'].setEnabled(False)
    app.actions['actionRecord'].setEnabled(False)

    resetCamera()


def planeFit():
    planefit.fitPlane()

def setDefaultLookupTables(sourceProxy):

    # LUT for 'intensity'
    smp.GetLookupTableForArray(
      'intensity', 1,
      ScalarRangeInitialized=1.0,
      ColorSpace='HSV',
      RGBPoints=[0.0, 0.0, 0.0, 1.0,
               100.0, 1.0, 1.0, 0.0,
               256.0, 1.0, 0.0, 0.0])

    # LUT for 'dual_distance'
    smp.GetLookupTableForArray(
      'dual_distance', 1,
      InterpretValuesAsCategories=True, NumberOfTableValues=3,
      RGBPoints=[-1.0, 0.1, 0.5, 0.7,
                  0.0, 0.9, 0.9, 0.9,
                 +1.0, 0.8, 0.2, 0.3],
      Annotations=['-1', 'near', '0', 'dual', '1', 'far'])

    # LUT for 'dual_intensity'
    smp.GetLookupTableForArray(
      'dual_intensity', 1,
      InterpretValuesAsCategories=True, NumberOfTableValues=3,
      RGBPoints=[-1.0, 0.5, 0.2, 0.8,
                  0.0, 0.6, 0.6, 0.6,
                 +1.0, 1.0, 0.9, 0.4],
      Annotations=['-1', 'low', '0', 'dual', '1', 'high'])

def colorByIntensity(sourceProxy):

    if not hasArrayName(sourceProxy, 'intensity'):
        return False

    setDefaultLookupTables(sourceProxy)
    rep = smp.GetDisplayProperties(sourceProxy)
    rep.ColorArrayName = 'intensity'
    rep.LookupTable = smp.GetLookupTableForArray('intensity', 1)
    return True


def getTimeStamp():
    format = '%Y-%m-%d-%H-%M-%S'
    return datetime.datetime.now().strftime(format)


def getReaderFileName():
    filename = getReader().FileName
    return filename[0] if isinstance(filename, servermanager.FileNameProperty) else filename


def getDefaultSaveFileName(extension, suffix='', appendFrameNumber=False):

    sensor = getSensor()
    reader = getReader()

    if sensor:
        nchannels =  sensor.GetPropertyValue('NumberOfChannels')
        base = 'RS-'
        if nchannels <= 16:
            base = 'RS-'
        sensortype = base + str(nchannels)

        return '%s-%s-Data.%s' % (getTimeStamp(), sensortype, extension)

    if reader:
        basename =  os.path.splitext(os.path.basename(getReaderFileName()))[0]
        if appendFrameNumber:
            suffix = '%s (Frame %04d)' % (suffix, int(app.scene.AnimationTime))
        return '%s%s.%s' % (basename, suffix, extension)


def chooseCalibration():

    class Calibration(object):
        def __init__(self, dialog):
            self.calibrationFile = dialog.selectedCalibrationFile()
            self.lidarType = dialog.selectedSensor()
            self.gpsYaw = dialog.gpsYaw()
            self.gpsRoll = dialog.gpsRoll()
            self.gpsPitch = dialog.gpsPitch()
            self.sensorTransform = vtk.vtkTransform()

            qm = dialog.sensorTransform()
            vm = vtk.vtkMatrix4x4()
            for row in xrange(4):
                vm.SetElement(row, 0, qm.row(row).x())
                vm.SetElement(row, 1, qm.row(row).y())
                vm.SetElement(row, 2, qm.row(row).z())
                vm.SetElement(row, 3, qm.row(row).w())
            self.sensorTransform.SetMatrix(vm)

    dialog = vvCalibrationDialog(getMainWindow())
    if not dialog.exec_():
        return None

    return Calibration(dialog)

def openSensor():

    close()

    cont = chooseCalibrationFile(False)
    if not cont:
        return None

    dialog = vvCalibrationDialog(getMainWindow())
    lidarType = dialog.GetSensorType()
    calibPath = dialog.GetCalibrationPath()
    sensorPosition = dialog.GetPosition()

    cont = networkConfigSensor(False)
    if not cont:
        return None

    dialog = vvNetworkConfigSensorDialog(getMainWindow())
    msopPort = dialog.GetMsopPort()
    difopPort = dialog.GetDifopPort()
    userLayerBytes = dialog.GetUserLayerBytes()
    tailLayerBytes = dialog.GetTailLayerBytes()
    groupAddress = dialog.groupAddress()
    hostAddress = dialog.hostAddress()

    dialog = vvLaserSelectionDialog(getMainWindow())
    laserSelected = dialog.getLaserSelection()

    dialog = vvPointsSelectionDialog(getMainWindow())
    pointsSelection = dialog.getPointsSelection()

    dialog = vvCropReturnsDialog(getMainWindow())
    cropReturns = dialog.GetCropReturns()

    sensor = smp.RSlidar16Source(guiName='Data', 
                                 LidarType=lidarType,
                                 CalibrationPath=calibPath,
                                 SensorPosition=sensorPosition,
                                 MsopPort=msopPort,
                                 DifopPort=difopPort,
                                 GroupAddress=groupAddress,
                                 HostAddress=hostAddress,
                                 UserLayerBytes=userLayerBytes,
                                 TailLayerBytes=tailLayerBytes)

    sensor.Init()
    sensor.GetClientSideObject().SetLaserSelection(laserSelected)
    sensor.GetClientSideObject().SetPointsRange(pointsSelection)
    sensor.GetClientSideObject().SetCropReturns(cropReturns)
    #sensor.UpdatePipeline()

    #if SAMPLE_PROCESSING_MODE:
    #    processor = smp.ProcessingSample(sensor)

    smp.GetActiveView().ViewTime = 0.0

    app.sensor = sensor
    app.colorByInitialized = False

    app.filenameLabel.setText('Live Sensor Stream')

    enablePlaybackActions()
    enableSaveActions()
    #onCropReturns(False) # Dont show the dialog just restore settings

    rep = smp.Show(sensor)
    app.rep = rep
    app.rep.PointSize = app.pointSize
    app.rep.SelectionPointSize = app.pointSize + 3
    rep.InterpolateScalarsBeforeMapping = 0

    #if SAMPLE_PROCESSING_MODE:
    #    prep = smp.Show(processor)

    smp.Render()

    showSourceInSpreadSheet(sensor)

    play()
    app.tempTimer.start(1)

def openPCAP(filename, positionFilename=None):

    close()

    cont = chooseCalibrationFile(False)
    if not cont:
        return None

    dialog = vvCalibrationDialog(getMainWindow())
    lidarType = dialog.GetSensorType()
    calibPath = dialog.GetCalibrationPath()
    sensorPosition = dialog.GetPosition()

    cont = networkConfigPcap(False)
    if not cont:
        return None

    dialog = vvNetworkConfigPcapDialog(getMainWindow())

    useVlan = dialog.GetUseVlan()
    userLayerBytes = dialog.GetUserLayerBytes()
    tailLayerBytes = dialog.GetTailLayerBytes()
    msopPort = dialog.GetMsopPort()
    difopPort = dialog.GetDifopPort()

    dialog = vvLaserSelectionDialog(getMainWindow())
    laserSelected = dialog.getLaserSelection()

    dialog = vvCropReturnsDialog(getMainWindow())
    cropReturns = dialog.GetCropReturns()

    dialog = vvPointsSelectionDialog(getMainWindow())
    pointsSelection = dialog.getPointsSelection()

    def onProgressEvent(o, e):
        PythonQt.QtGui.QApplication.instance().processEvents()

    # start parsing file ...

    progressDialog = QtGui.QProgressDialog('Reading PCAP file...', '', 0, 0, getMainWindow())
    progressDialog.setCancelButton(None)
    progressDialog.setModal(True)
    progressDialog.show()

    handler = servermanager.ActiveConnection.Session.GetProgressHandler()
    handler.PrepareProgress()
    freq = handler.GetProgressFrequency()
    handler.SetProgressFrequency(0.05)
    tag = handler.AddObserver('ProgressEvent', onProgressEvent)

    reader = smp.RSlidar16Reader(guiName='Data',
                                 LidarType=lidarType,
                                 FileName=filename,
                                 CalibrationPath=calibPath,
                                 SensorPosition=sensorPosition,
                                 MsopPort=msopPort,
                                 DifopPort=difopPort,
                                 UseVlan=useVlan,
                                 UserLayerBytes=userLayerBytes,
                                 TailLayerBytes=tailLayerBytes)

    reader.Init()
    reader.GetClientSideObject().SetLaserSelection(laserSelected)
    reader.GetClientSideObject().SetPointsRange(pointsSelection)
    reader.GetClientSideObject().SetNumberOfTrailingFrames(app.numberOfTrailingFrames)
    reader.GetClientSideObject().SetCropReturns(cropReturns)
    reader.UpdatePipelineInformation()

    app.reader = reader
    app.filenameLabel.setText('File: %s' % os.path.basename(filename))
    #onCropReturns(False) # Dont show the dialog just restore settings

    #if SAMPLE_PROCESSING_MODE:
    #    processor = smp.ProcessingSample(reader)

    handler.RemoveObserver(tag)
    handler.SetProgressFrequency(freq)
    progressDialog.close()

    # end parsing file.

    smp.GetActiveView().ViewTime = 0.0

    rep = smp.Show(reader)  
    app.rep = rep
    app.rep.PointSize = app.pointSize
    app.rep.SelectionPointSize = app.pointSize + 3

    #if SAMPLE_PROCESSING_MODE:
    #    prep = smp.Show(processor)
    app.scene.UpdateAnimationUsingDataTimeSteps()

    # update overhead view
    smp.SetActiveView(app.overheadView)

    if positionFilename is None:
        posreader = smp.RSlidar16PositionReader(guiName="Position",
                                                UseVlan=useVlan,
                                                FileName=filename)
    else:
        posreader = smp.ApplanixPositionReader(guiName="Position",
                                               FileName=positionFilename)
        posreader.BaseYaw = calibration.gpsYaw
        posreader.BaseRoll = calibration.gpsRoll
        posreader.BasePitch = calibration.gpsPitch

    smp.Show(posreader)

    # Create a sphere glyph
    g = smp.Sphere()
    g.Radius = 5.0
    smp.Show(g)

    if posreader.GetClientSideObject().GetOutput().GetNumberOfPoints():
        reader.GetClientSideObject().SetInterpolator(
            posreader.GetClientSideObject().GetInterpolator())

        smp.Render(app.overheadView)
        app.overheadView.ResetCamera()

        trange = posreader.GetPointDataInformation().GetArray('time').GetRange()

        # By construction time zero is at position 0,0,0

        # Setup scalar bar
        rep = smp.GetDisplayProperties(posreader)
        rep.ColorArrayName = 'time'
        rgbPoints = [trange[0], 0.0, 0.0, 1.0,
                     trange[1], 1.0, 0.0, 0.0]
        rep.LookupTable = smp.GetLookupTableForArray('time', 1,
                                                     RGBPoints=rgbPoints,
                                                     ScalarRangeInitialized=1.0)
        sb = smp.CreateScalarBar(LookupTable=rep.LookupTable, Title='Time')
        sb.Orientation = 'Horizontal'
        sb.Position, sb.Position2 = [.1, .05], [.8, .02]
        app.overheadView.Representations.append(sb)

        app.position = (posreader, None, g)
        smp.Render(app.overheadView)
    else:
        if positionFilename is not None:
            QtGui.QMessageBox.warning(getMainWindow(), 'Georeferncing data invalid',
                                      'File %s is not supported' % positionFilename)

        smp.Delete(posreader)

    smp.SetActiveView(app.mainView)
    smp.SetActiveSource(reader)

    rep.InterpolateScalarsBeforeMapping = 0
    setDefaultLookupTables(reader)
    colorByIntensity(reader)

    showSourceInSpreadSheet(reader)

    updateSliderTimeRange()
    updatePosition()
    enablePlaybackActions()
    enableSaveActions()
    addRecentFile(filename)
    app.actions['actionRecord'].setEnabled(False)

    resetCamera()
    app.tempTimer.start(1)

def hideMeasurementGrid():

    rep = smp.GetDisplayProperties(app.grid)
    rep.Visibility = 0
    smp.Render()


def showMeasurementGrid():

    rep = smp.GetDisplayProperties(app.grid)
    rep.Visibility = 1
    smp.Render()

#
# Start Functions related to ruler
#

def createRuler():
    pxm = servermanager.ProxyManager()
    distancerep = pxm.NewProxy('representations', 'DistanceWidgetRepresentation')
    distancerepeasy = servermanager._getPyProxy(distancerep)
    smp.GetActiveView().Representations.append(distancerepeasy)
    distancerepeasy.Visibility = False
    smp.Render()

    return distancerepeasy


def hideRuler():
    app.ruler.Visibility = False
    smp.Render()


def showRuler():
    app.ruler.Visibility = True
    smp.Render()

def getPointFromCoordinate(coord, midPlaneDistance = 0.5):
    assert len(coord) == 2

    windowHeight = smp.GetActiveView().ViewSize[1]

    displayPoint = [coord[0], windowHeight - coord[1], midPlaneDistance]
    renderer = smp.GetActiveView().GetRenderer()
    renderer.SetDisplayPoint(displayPoint)
    renderer.DisplayToWorld()
    world1 = renderer.GetWorldPoint()

    return world1[:3]

def toggleRulerContext():

    measurmentState = app.actions['actionMeasure'].isChecked()

    mW = getMainWindow()
    vtkW = mW.findChild('pqQVTKWidget')

    if measurmentState == True:
        vtkW.connect('mouseEvent(QMouseEvent*)', setRulerCoordinates)

    elif measurmentState == False:
        vtkW.disconnect('mouseEvent(QMouseEvent*)', setRulerCoordinates)

        app.mousePressed = False
        hideRuler()


def setRulerCoordinates(mouseEvent):

    pqView = smp.GetActiveView()
    rW = pqView.GetRenderWindow()
    windowInteractor = rW.GetInteractor()
    currentMouseState = mouseEvent.buttons()
    currentKeyboardState = mouseEvent.modifiers()

    if currentMouseState == 1:  #Left button pressed

        if app.mousePressed == False: #For the first time

            if currentKeyboardState == 67108864: #Control key pressed

                app.mousePressed = True
                app.ruler.Point1WorldPosition = getPointFromCoordinate([mouseEvent.x(),mouseEvent.y()])

                windowInteractor.Disable()

        elif app.mousePressed == True: #Not for the first time

            app.ruler.Point2WorldPosition = getPointFromCoordinate([mouseEvent.x(),mouseEvent.y()])
            showRuler()
            smp.Render()

    elif currentMouseState == 0: #Left button released

        windowInteractor.Enable()

        if  app.mousePressed == True: #For the first time

            app.mousePressed = False
            app.ruler.Point2WorldPosition = getPointFromCoordinate([mouseEvent.x(),mouseEvent.y()])
            showRuler()
            smp.Render()


# End Functions related to ruler


def rotateCSVFile(filename):

    # read the csv file, move the last 3 columns to the
    # front, and then overwrite the file with the result
    csvFile = open(filename, 'rb')
    reader = csv.reader(csvFile, quoting=csv.QUOTE_NONNUMERIC)
    rows = [row[-3:] + row[:-3] for row in reader]
    csvFile.close()

    writer = csv.writer(open(filename, 'wb'), quoting=csv.QUOTE_NONNUMERIC, delimiter=',')
    writer.writerows(rows)


def savePositionCSV(filename):
    w = smp.CreateWriter(filename, getPosition())
    w.Precision = 16
    w.FieldAssociation = 'Points'
    w.UpdatePipeline()
    smp.Delete(w)

def saveCSVCurrentFrame(filename):
    w = smp.CreateWriter(filename, smp.GetActiveSource())
    w.Precision = 16
    w.FieldAssociation = 'Points'
    w.UpdatePipeline()
    smp.Delete(w)
    rotateCSVFile(filename)

def savePCDFrames(filename, first, last, transform):
    reader = getReader().GetClientSideObject()

    PythonQt.paraview.pqRSlidarManager.saveFramesToPCD(
        reader, None, first, last, filename, transform)

def savePCDCurrentFrame(filename, transform):
    t = app.scene.AnimationTime
    savePCDFrames(filename, t, t, transform)

def saveLASFrames(filename, first, last, transform):
    reader = getReader().GetClientSideObject()
    #position = getPosition().GetClientSideObject().GetOutput()

    PythonQt.paraview.pqRSlidarManager.saveFramesToLAS(
        reader, None, first, last, filename, transform)
        #reader, position, first, last, filename, transform)


def saveLASCurrentFrame(filename, transform):
    t = app.scene.AnimationTime
    saveLASFrames(filename, t, t, transform)


def saveAllFrames(filename, saveFunction):
    saveFunction(filename, getCurrentTimesteps())


def saveFrameRange(filename, frameStart, frameStop, saveFunction):
    timesteps = range(frameStart, frameStop+1)
    saveFunction(filename, timesteps)


def saveCSV(filename, timesteps):

    tempDir = kiwiviewerExporter.tempfile.mkdtemp()
    basenameWithoutExtension = os.path.splitext(os.path.basename(filename))[0]
    outDir = os.path.join(tempDir, basenameWithoutExtension)
    filenameTemplate = os.path.join(outDir, basenameWithoutExtension + ' (Frame %04d).csv')
    os.makedirs(outDir)

    writer = smp.CreateWriter('tmp.csv', getSensor() or getReader())
    writer.FieldAssociation = 'Points'
    writer.Precision = 16

    for t in timesteps:
        app.scene.AnimationTime = t
        writer.FileName = filenameTemplate % t
        writer.UpdatePipeline()
        rotateCSVFile(writer.FileName)

    smp.Delete(writer)

    kiwiviewerExporter.zipDir(outDir, filename)
    kiwiviewerExporter.shutil.rmtree(tempDir)


def saveLAS(filename, timesteps, transform):

    tempDir = kiwiviewerExporter.tempfile.mkdtemp()
    basenameWithoutExtension = os.path.splitext(os.path.basename(filename))[0]
    outDir = os.path.join(tempDir, basenameWithoutExtension)
    filenameTemplate = os.path.join(outDir, basenameWithoutExtension + ' (Frame %04d).las')
    os.makedirs(outDir)

    for t in sorted(timesteps):
        saveLASFrames(filenameTemplate % t, t, t, transform)

    kiwiviewerExporter.zipDir(outDir, filename)
    kiwiviewerExporter.shutil.rmtree(tempDir)

def savePCD(filename, timesteps, transform):

    tempDir = kiwiviewerExporter.tempfile.mkdtemp()
    basenameWithoutExtension = os.path.splitext(os.path.basename(filename))[0]
    outDir = os.path.join(tempDir, basenameWithoutExtension)
    filenameTemplate = os.path.join(outDir, basenameWithoutExtension + ' (Frame %04d).pcd')
    os.makedirs(outDir)

    for t in sorted(timesteps):
        savePCDFrames(filenameTemplate % t, t, t, transform)

    kiwiviewerExporter.zipDir(outDir, filename)
    kiwiviewerExporter.shutil.rmtree(tempDir)


def getTimeStamp():
    format = '%Y-%m-%d-%H-%M-%S'
    return datetime.datetime.now().strftime(format)


def getSaveFileName(title, extension, defaultFileName=None):

    settings = getPVSettings()
    defaultDir = settings.value('RSlidar16Plugin/SaveData/DefaultDir', QtCore.QDir.homePath())
    defaultFileName = defaultDir if not defaultFileName else os.path.join(defaultDir, defaultFileName)

    nativeDialog = 0 if app.actions['actionNative_File_Dialogs'].isChecked() else QtGui.QFileDialog.DontUseNativeDialog

    filters = '%s (*.%s)' % (extension, extension)
    selectedFilter = '*.%s' % extension
    fileName = QtGui.QFileDialog.getSaveFileName(getMainWindow(), title,
                        defaultFileName, filters, selectedFilter, nativeDialog)

    if fileName:
        settings.setValue('RSlidar16Plugin/SaveData/DefaultDir', QtCore.QFileInfo(fileName).absoluteDir().absolutePath())
        return fileName


def getFrameSelectionFromUser(frameStrideVisibility=False, framePackVisibility=False, frameTransformVisibility=False):
    class FrameOptions(object):
        pass

    dialog = PythonQt.paraview.vvSelectFramesDialog(getMainWindow())
    dialog.frameMinimum = app.scene.StartTime
    dialog.frameMaximum = app.scene.EndTime
    dialog.frameStrideVisibility = frameStrideVisibility
    dialog.framePackVisibility = framePackVisibility
    dialog.frameTransformVisibility = frameTransformVisibility
    dialog.restoreState()

    if not dialog.exec_():
        return None

    frameOptions = FrameOptions()
    frameOptions.mode = dialog.frameMode
    frameOptions.start = dialog.frameStart
    frameOptions.stop = dialog.frameStop
    frameOptions.stride = dialog.frameStride
    frameOptions.pack = dialog.framePack
    frameOptions.transform = dialog.frameTransform

    dialog.setParent(None)

    return frameOptions


def onSaveCSV():

    frameOptions = getFrameSelectionFromUser()
    if frameOptions is None:
        return


    if frameOptions.mode == vvSelectFramesDialog.CURRENT_FRAME:
        fileName = getSaveFileName('Save CSV', 'csv', getDefaultSaveFileName('csv', appendFrameNumber=True))
        if fileName:
            oldTransform = transformMode()
            setTransformMode(1 if frameOptions.transform else 0)

            saveCSVCurrentFrame(fileName)

            setTransformMode(oldTransform)

    else:
        fileName = getSaveFileName('Save CSV (to zip file)', 'zip', getDefaultSaveFileName('zip'))
        if fileName:
            oldTransform = transformMode()
            setTransformMode(1 if frameOptions.transform else 0)

            if frameOptions.mode == vvSelectFramesDialog.ALL_FRAMES:
                saveAllFrames(fileName, saveCSV)
            else:
                start = frameOptions.start
                stop = frameOptions.stop
                saveFrameRange(fileName, start, stop, saveCSV)

            setTransformMode(oldTransform)


def onSavePosition():
    fileName = getSaveFileName('Save CSV', 'csv', getDefaultSaveFileName('csv', '-position'))
    if fileName:
        savePositionCSV(fileName)


def onSaveLAS():

    frameOptions = getFrameSelectionFromUser(framePackVisibility=True, frameTransformVisibility=False)
    if frameOptions is None:
        return

    if frameOptions.mode == vvSelectFramesDialog.CURRENT_FRAME:
        frameOptions.start = frameOptions.stop = app.scene.AnimationTime
    elif frameOptions.mode == vvSelectFramesDialog.ALL_FRAMES:
        frameOptions.start = int(app.scene.StartTime)
        frameOptions.stop = int(app.scene.EndTime)

    if frameOptions.mode == vvSelectFramesDialog.CURRENT_FRAME:
        fileName = getSaveFileName('Save LAS', 'las', getDefaultSaveFileName('las', appendFrameNumber=True))
        if fileName:
            oldTransform = transformMode()
            setTransformMode(1 if frameOptions.transform else 0)

            saveLASCurrentFrame(fileName, frameOptions.transform)

            setTransformMode(oldTransform)

    elif frameOptions.pack == vvSelectFramesDialog.FILE_PER_FRAME:
        fileName = getSaveFileName('Save LAS (to zip file)', 'zip',
                                   getDefaultSaveFileName('zip'))
        if fileName:
            oldTransform = transformMode()
            setTransformMode(1 if frameOptions.transform else 0)

            def saveTransformedLAS(filename, timesteps):
                saveLAS(filename, timesteps, frameOptions.transform)

            if frameOptions.mode == vvSelectFramesDialog.ALL_FRAMES:
                saveAllFrames(fileName, saveTransformedLAS)
            else:
                start = frameOptions.start
                stop = frameOptions.stop
                saveFrameRange(fileName, start, stop, saveTransformedLAS)

            setTransformMode(oldTransform)

    else:
        suffix = ' (Frame %d to %d)' % (frameOptions.start, frameOptions.stop)
        defaultFileName = getDefaultSaveFileName('las', suffix=suffix)
        fileName = getSaveFileName('Save LAS', 'las', defaultFileName)
        if not fileName:
            return

        oldTransform = transformMode()
        setTransformMode(1 if frameOptions.transform else 0)

        saveLASFrames(fileName, frameOptions.start, frameOptions.stop,
                      frameOptions.transform)

        setTransformMode(oldTransform)

def onSavePCD():

    frameOptions = getFrameSelectionFromUser(framePackVisibility=True, frameTransformVisibility=False)
    if frameOptions is None:
        return

    if frameOptions.mode == vvSelectFramesDialog.CURRENT_FRAME:
        frameOptions.start = frameOptions.stop = app.scene.AnimationTime
    elif frameOptions.mode == vvSelectFramesDialog.ALL_FRAMES:
        frameOptions.start = int(app.scene.StartTime)
        frameOptions.stop = int(app.scene.EndTime)

    if frameOptions.mode == vvSelectFramesDialog.CURRENT_FRAME:
        fileName = getSaveFileName('Save PCD', 'pcd', getDefaultSaveFileName('pcd', appendFrameNumber=True))
        if fileName:
            oldTransform = transformMode()
            setTransformMode(1 if frameOptions.transform else 0)

            savePCDCurrentFrame(fileName, frameOptions.transform) # todo

            setTransformMode(oldTransform)

    elif frameOptions.pack == vvSelectFramesDialog.FILE_PER_FRAME:
        fileName = getSaveFileName('Save PCD (to zip file)', 'zip',
                                   getDefaultSaveFileName('zip'))
        if fileName:
            oldTransform = transformMode()
            setTransformMode(1 if frameOptions.transform else 0)

            def saveTransformedPCD(filename, timesteps):
                savePCD(filename, timesteps, frameOptions.transform) # todo

            if frameOptions.mode == vvSelectFramesDialog.ALL_FRAMES:
                saveAllFrames(fileName, saveTransformedPCD)  # todo
            else:
                start = frameOptions.start
                stop = frameOptions.stop
                saveFrameRange(fileName, start, stop, saveTransformedPCD) # todo

            setTransformMode(oldTransform)

    else:
        suffix = ' (Frame %d to %d)' % (frameOptions.start, frameOptions.stop)
        defaultFileName = getDefaultSaveFileName('pcd', suffix=suffix)
        fileName = getSaveFileName('Save LAS', 'pcd', defaultFileName)
        if not fileName:
            return

        oldTransform = transformMode()
        setTransformMode(1 if frameOptions.transform else 0)

        savePCDFrames(fileName, frameOptions.start, frameOptions.stop, # todo
                      frameOptions.transform)

        setTransformMode(oldTransform)

def onSavePCAP():

    frameOptions = getFrameSelectionFromUser(frameTransformVisibility=False)
    if frameOptions is None:
        return

    if frameOptions.mode == vvSelectFramesDialog.CURRENT_FRAME:
        frameOptions.start = frameOptions.stop = app.scene.AnimationTime
    elif frameOptions.mode == vvSelectFramesDialog.ALL_FRAMES:
        frameOptions.start = int(app.scene.StartTime)
        frameOptions.stop = int(app.scene.EndTime)

    defaultFileName = getDefaultSaveFileName('pcap', suffix=' (Frame %d to %d)' % (frameOptions.start, frameOptions.stop))
    fileName = getSaveFileName('Save PCAP', 'pcap', defaultFileName)
    if not fileName:
        return

    reader = getReader()
    if reader:
        reader.GetClientSideObject().saveFramesToPCAP(frameOptions.start, frameOptions.stop, fileName)

    #PythonQt.paraview.pqRSlidarManager.saveFramesToPCAP(getReader().SMProxy, frameOptions.start, frameOptions.stop, fileName)


def onSaveScreenshot():

    fileName = getSaveFileName('Save Screenshot', 'png', getDefaultSaveFileName('png', appendFrameNumber=True))
    if fileName:
        saveScreenshot(fileName)

def exportToDirectory(outDir, timesteps):

    filenames = []

    alg = smp.GetActiveSource().GetClientSideObject()

    writer = vtkXMLPolyDataWriter()
    writer.SetDataModeToAppended()
    writer.EncodeAppendedDataOff()
    writer.SetCompressorTypeToZLib()

    for t in timesteps:

        filename = 'frame_%04d.vtp' % t
        filenames.append(filename)

        app.scene.AnimationTime = t
        polyData = vtk.vtkPolyData()
        polyData.ShallowCopy(alg.GetOutput())

        writer.SetInputData(polyData)
        writer.SetFileName(os.path.join(outDir, filename))
        writer.Update()

    return filenames


def getVersionString():
  return QtGui.QApplication.instance().applicationVersion

def onAbout():
    title = 'About RSView'
    text = '''<h1>RSView %s</h1>
              <br/><br/>Copyright (c) 2017-2023, All Rights Reserved.''' % getVersionString()

    QtGui.QMessageBox.about(getMainWindow(), title, text)

def onLicenseInfo():
    title = 'License Information'
    text = '''<h1>RSView %s</h1>
           This software uses below open source components whose copyright and other proprietary rights belong to their respective owners.
           Please find corresponding license files in the license directory.
           <br/>
           <table width="800" border="1" bgcolor="white" cellspacing="0">
           <tr> 
             <th> COMPONENT   </th> 
             <th> LICENSE     </th> 
             <th> COPYRIGHT   </th> 
             <th> STATE       </th> 
           </tr>
           <tr> 
             <td> VeloView  </td> 
             <td> Apache     </td> 
             <td> Copyright (c) 2005-2008 Sandia Corporation, Kitware Inc. https://www.kitware.com/ </td> 
             <td> not changed </td> 
           </tr>
           <tr> 
             <td> ParaView/VTK v4.3.1  </td> 
             <td> ParaView/VTK License </td> 
             <td> Copyright (c) 2005-2008 Sandia Corporation, Kitware Inc. https://www.kitware.com/ </td> 
             <td> not changed </td> 
           </tr>
           <tr> 
             <td> Qt v4.8.6   </td> 
             <td> LGPLv2.0   </td> 
             <td> The Qt Group. https://www.qt.io/ </td> 
             <td> not changed </td> 
           </tr>
           <tr> 
             <td> Python v2.7.3 </td> 
             <td> Python License </td> 
             <td> https://www.python.org/ </td> 
             <td> not changed </td> 
           </tr>
           <tr> 
             <td> pythonqt  </td> 
             <td> LGPLv2.0 </td> 
             <td> https://mevislab.github.io/pythonqt/ </td> 
             <td> not changed </td> 
           </tr>
           <tr> 
             <td> Boost v1.50.0 </td> 
             <td> Boost License </td> 
             <td> The Boost Organization. https://www.boost.org/ </td> 
             <td> not changed </td> 
           </tr>
           <tr> 
             <td> pcap v1.4.0 </td> 
             <td> BSD </td> 
             <td> The TCPDUMP & LIBPCAP Group. https://www.tcpdump.org/ </td> 
             <td> not changed </td> 
           </tr>
           <tr> 
             <td> Eigen v3.1.2 </td> 
             <td> Molliza MPL </td> 
             <td> Benoit Jacob, Gael Guennebaud and many other people. http://eigen.tuxfamily.org/ </td> 
             <td> not changed </td> 
           </tr>
           <tr> 
             <td> liblas v1.2 </td> 
             <td> liblas License </td> 
             <td> Copyright (c) 2007-2008, Martin Isenburg and other people. https://liblas.org/ </td> 
             <td> not changed </td> 
           </tr>
           </table>''' % getVersionString()

    QtGui.QMessageBox.about(getMainWindow(), title, text)

def onUserGuide():
    basePath = PythonQt.QtGui.QApplication.instance().applicationDirPath()

    paths = ["../../doc/RSView_User_Guide_CN.pdf"]

    for path in paths:
        filename = os.path.join(basePath, path)
        if os.path.isfile(filename):
            QtGui.QDesktopServices.openUrl(QtCore.QUrl('file:///%s' % filename, QtCore.QUrl.TolerantMode))

def close():

    stop()
    hideRuler()
    unloadData()
    smp.Render(app.overheadView)
    app.scene.AnimationTime = 0
    app.reader = None
    app.sensor = None

    smp.HideUnusedScalarBars()

    resetCameraToForwardView()
    app.filenameLabel.setText('')
    app.timeLabel.setText('')
    app.localTime.setText('')
    app.framerate.setText('')
    app.tempLabel.setText('')
    app.statusLabel.setText('')

    updateSliderTimeRange()
    disablePlaybackActions()
    disableSaveActions()
    app.actions['actionRecord'].setChecked(False)

def seekForward():

    if app.playing:

        # playDirection = -1 1-speed/normal-speed, reverse
        #                 -2 2-speed, reverse
        #                 -3 3-speed, reverse
        #                 -4 1/2 speed, reverse
        #                 -5 1/4 speed, reverse
        if app.playDirection < 0:
            app.playDirection = 1
        else:
            app.playDirection += 1

            if app.playDirection > 5:
                app.playDirection = 1

        updateSeekButtons()

    else:
        gotoNext()


def seekBackward():

    if app.playing:

        # playDirection = 1 1-speed/normal-speed
        #                 2 2-speed
        #                 3 3-speed
        #                 4 1/2 speed
        #                 5 1/4 speed
        if app.playDirection > 0:
            app.playDirection = -1
        else:
            app.playDirection -= 1

            if app.playDirection < -5:
                app.playDirection = -1

        updateSeekButtons()

    else:
        gotoPrevious()


def seekPressTimeout():

    app.seekPlay = True

    onPlayTimer()

def seekForwardPressed():

    app.seekPlayDirection = 1

    if not app.playing:
        app.seekTimer.start(500)


def seekForwardReleased():

    app.seekTimer.stop()

    app.seekPlay = False

def seekBackwardPressed():

    app.seekPlayDirection = -1

    if not app.playing:
        app.seekTimer.start(500)

def seekBackwardReleased():

    seekForwardReleased()

def updateSeekButtons():

    icons = {
              -5 : IconPaths.seekBackwardQuarterx,
              -4 : IconPaths.seekBackwardHalfx,
              -3 : IconPaths.seekBackward3x,
              -2 : IconPaths.seekBackward2x,
              -1 : IconPaths.seekBackward1x,
               1 : IconPaths.seekForward,
               2 : IconPaths.seekForward2x,
               3 : IconPaths.seekForward3x,
               4 : IconPaths.seekForwardHalfx,
               5 : IconPaths.seekForwardQuarterx,
            }

    setActionIcon('actionSeek_Backward', icons[app.playDirection] if app.playDirection < 0 else IconPaths.seekBackward)
    setActionIcon('actionSeek_Forward', icons[app.playDirection] if app.playDirection > 0 else IconPaths.seekForward)

    #
    # For slow play:
    #   1. calculate interval between adjacent frames. (Here calculate targetFps, from which we gets the interval)
    #   2. locate the frame by the interval.
    # 
    fpsDefault = 10 #30
    fpsMap = {-5:2, -4:5, 4:5, 5:2} #fpsMap = {-5:5, 5:5, -4:11, 4:11}
    app.targetFps = fpsMap.get(app.playDirection, fpsDefault)


def setPlaybackActionsEnabled(enabled):
    for action in ('Play', 'Record', 'Seek_Forward', 'Seek_Backward', 'Go_To_Start', 'Go_To_End'):
        app.actions['action'+action].setEnabled(enabled)

def enablePlaybackActions():
    setPlaybackActionsEnabled(True)


def disablePlaybackActions():
    setPlaybackActionsEnabled(False)


def _setSaveActionsEnabled(enabled):
    for action in ('SaveCSV', 'SavePCAP', 'SaveLAS', 'SavePCD', 'Export_To_KiwiViewer', 'Close', 'CropReturns'):
        app.actions['action'+action].setEnabled(enabled)
    getMainWindow().findChild('QMenu', 'menuSaveAs').enabled = enabled


def enableSaveActions():
    _setSaveActionsEnabled(True)
    if getPosition():
        app.actions['actionSavePositionCSV'].setEnabled(True)


def disableSaveActions():
    _setSaveActionsEnabled(False)
    app.actions['actionSavePositionCSV'].setEnabled(False)

def onPointsSizeChanged(pointsSize):
    app.pointSize = pointsSize

    try:
        app.rep.PointSize = pointsSize
        app.rep.SelectionPointSize = pointsSize + 3
        smp.Render()
        smp.Render(getSpreadSheetViewProxy())
    except AttributeError:
        pass

def onRecord():

    sensor = getSensor()
    if sensor is None:
        return

    recordAction = app.actions['actionRecord']

    if not recordAction.isChecked():
        sensor.GetClientSideObject().StopRecording()
        app.statusLabel.setText('')

    else:
        fileName = getSaveFileName('Choose Output File', 'pcap', getDefaultSaveFileName('pcap'))
        if not fileName:
            recordAction.setChecked(False)
            return

        sensor.GetClientSideObject().StartRecording(fileName)
        app.statusLabel.setText('  Recording file: %s' % os.path.basename(fileName))


def startStream():

    sensor = getSensor()
    if sensor:
        sensor.Start()

def stopStream():
    sensor = getSensor()
    if sensor:
        sensor.Stop()

def pollSource():

    source = getSensor()
    reader = getReader()
    if source is not None:
        #source.Poll()
        source.UpdatePipelineInformation()
    return source or reader


def getPointCloudData(attribute=None):

    if attribute is not None:
        data = getPointCloudData()
        if data:
            if attribute == 'points':
                return data.GetPoints().GetData()
            else:
                return data.GetPointData().GetArray(attribute)
    else:
        source = getSensor() or getReader()
        if source:
            return source.GetClientSideObject().GetOutput()


def getCurrentTimesteps():
    source = pollSource()
    return list(source.TimestepValues) if source is not None else []


def getNumberOfTimesteps():
    return getTimeKeeper().getNumberOfTimeStepValues()


def togglePlay():
    setPlayMode(not app.playing)

def play():
    setPlayMode(True)


def stop():
    setPlayMode(False)


def onPlayTimer():

    if app.playing or app.seekPlay:

        startTime = vtk.vtkTimerLog.GetUniversalTime()

        playbackTick()

        #
        # For normal & fast play:
        #   1. calculate how many milliseconds to reach next frame
        #   2. wait for the milisends, and show the frame.
        #
        fpsDelayMilliseconds = int(1000.0 / app.targetFps)
        elapsedMilliseconds = int((vtk.vtkTimerLog.GetUniversalTime() - startTime)*1000.0)

        if elapsedMilliseconds > 0:
            fps = 1000.0/elapsedMilliseconds
            app.fps[0] += fps
            app.fps[1] += 1

        waitMilliseconds = fpsDelayMilliseconds - elapsedMilliseconds
        app.playTimer.start(max(waitMilliseconds,0))

def outputTempTimer():
    reader = getReader()
    sensor = getSensor()

    if reader:
        temp = reader.GetClientSideObject().OutputTemp()
        app.tempLabel.setText('  Temperature: %s  ' % temp)

    elif sensor:

        temp = sensor.GetClientSideObject().OutputTemp()
        app.tempLabel.setText('  Temperature: %s  ' % temp)

    app.tempTimer.start(1)


def setPlayMode(mode):

    if not getReader() and not getSensor():
        return

    app.playing = mode

    if mode:
        startStream()
        setActionIcon('actionPlay', IconPaths.pause)
        app.playTimer.start(33)
        if app.scene.AnimationTime == app.scene.EndTime:
            app.scene.AnimationTime = app.scene.StartTime

    else:
        stopStream()
        setActionIcon('actionPlay', IconPaths.play)
        app.playDirection = 1
        updateSeekButtons()


def gotoStart():
    pollSource()
    app.scene.GoToFirst()
    updatePosition()


def gotoEnd():
    pollSource()
    app.scene.GoToLast()
    updatePosition()


def gotoNext():
    pollSource()
    app.scene.GoToNext()
    updatePosition()


def gotoPrevious():
    pollSource()
    app.scene.GoToPrevious()
    updatePosition()


def updatePosition():
    reader = getReader()
    pos = getPosition()

    if reader and pos:
        pointcloud = reader.GetClientSideObject().GetOutput()

        if pointcloud.GetNumberOfPoints():
            # Update the overhead view
            # TODO: Approximate time, just grabbing the last
            t = pointcloud.GetPointData().GetScalars('adjustedtime')
            #currentTime = t.GetTuple1(t.GetNumberOfTuples() - 1)
            currentTime = t.GetTuple1(0) * 1e-6

            interp = getPosition().GetClientSideObject().GetInterpolator()
            trange = [interp.GetMinimumT(), interp.GetMaximumT()]

            # Clamp
            currentTime = min(max(currentTime, trange[0]+1.0e-1), trange[1]-1.0e-1)

            position = [0.0] * 3
            transform = vtk.vtkTransform()
            interp.InterpolateTransform(currentTime, transform)
            transform.TransformPoint(position, position)

            rep = cachedGetRepresentation(reader, view=app.mainView)
            if app.relativeTransform:
                rep.Position = transform.GetInverse().GetPosition()
                rep.Orientation = transform.GetInverse().GetOrientation()
            else:
                rep.Position = [0.0, 0.0, 0.0]
                rep.Orientation = [0.0, 0.0, 0.0]

            g = getGlyph()
            rep = cachedGetRepresentation(g, view=app.overheadView)
            rep.Position = position[:3]


def playbackTick():

    sensor = getSensor()
    reader = getReader()
    view = smp.GetActiveView()

    if sensor is not None:

        timesteps = getCurrentTimesteps()
        if not timesteps:
            return

        #if view.ViewTime == timesteps[-1]:
        #    return

        if not app.colorByInitialized:
            sensor.UpdatePipeline()
            if colorByIntensity(sensor):
                app.colorByInitialized = True
                resetCamera()

        app.scene.GoToLast()

    elif reader is not None:

        numberOfTimesteps = getNumberOfTimesteps()
        if not numberOfTimesteps:
            return

        #
        # For slow play:
        #   1. calculate interval between adjacent frames. (Here calculate it from targetFps)
        #   2. locate the frame by the interval.
        #
        step = app.seekPlayDirection if app.seekPlay else app.playDirection
        stepMap = {4:1, 5:1, -4:-1, -5:-1}
        step = stepMap.get(step, step)
        newTime = app.scene.AnimationTime + step

        if app.actions['actionLoop'].isChecked(): # loop mode
            newTime = newTime % numberOfTimesteps
        else: # non-loop mode
            newTime = max(app.scene.StartTime, min(newTime, app.scene.EndTime))

            # stop playback when it reaches the first or last timestep
            if newTime in (app.scene.StartTime, app.scene.EndTime):
                stop()

        app.scene.AnimationTime = newTime

        # TODO: For sensor as well?
        updatePosition()

def unloadData():
    _repCache.clear()

    for k, src in smp.GetSources().iteritems():
        if src != app.grid:
            smp.Delete(src)

    toremove = [x for x in app.overheadView.Representations if type(x) == servermanager.rendering.ScalarBarWidgetRepresentation]
    for t in toremove:
        app.overheadView.Representations.remove(t)

    app.reader = None
    app.sensor = None
    app.position = (None, None, None)

    clearSpreadSheetView()

def getReader():
    return getattr(app, 'reader', None)


def getSensor():
    return getattr(app, 'sensor', None)

def getPosition():
    return getattr(app, 'position', (None, None, None))[0]

def getGlyph():
    return getattr(app, 'position', (None, None, None))[2]

def onChooseCalibrationFile():
    chooseCalibrationFile(True)

def chooseCalibrationFile(force):

    dialog = vvCalibrationDialog(getMainWindow())
    if force == False and not dialog.GetShowDialog():
        return True

    oldType = dialog.GetSensorType()
    if not dialog.exec_():
        return False

    newType = dialog.GetSensorType()

    if newType != oldType:

        lidarTypeName = dialog.GetSensorTypeName()
        laserNum = dialog.GetLaserNum()

        app.lidarTypeLabel.setText('Lidar Type: %s' % lidarTypeName)

        dialog = vvLaserSelectionDialog(getMainWindow())
        dialog.reset(laserNum)

    return True

def onCropReturns(show = True):

    dialog = vvCropReturnsDialog(getMainWindow())
    if not dialog.exec_():
        return False

    cropReturns = dialog.GetCropReturns()

    reader = getReader()
    sensor = getSensor()

    if reader:
        reader.GetClientSideObject().SetCropReturns(cropReturns)
    elif sensor:
        sensor.GetClientSideObject().SetCropReturns(cropReturns)

def resetCamera():

    def subtract(a, b):
        result = range(3)
        vtk.vtkMath.Subtract(a, b, result)
        return result

    def cross(a, b):
        result = range(3)
        vtk.vtkMath.Cross(a, b, result)
        return result

    view = smp.GetActiveView()

    foc = list(view.CenterOfRotation)
    pos = list(view.CameraPosition)

    viewDirection = subtract(foc, pos)

    view.CameraPosition = subtract([0, 0, 0], viewDirection)
    view.CameraFocalPoint = [0, 0, 0]
    view.CenterOfRotation = [0, 0, 0]

    vtk.vtkMath.Normalize(viewDirection)

    perp = cross(viewDirection, [0, 0, 1])
    viewUp = cross(perp, viewDirection)
    view.CameraViewUp = viewUp

    view.StillRender()


def resetCameraToBirdsEyeView(view=None):

    view = view or smp.GetActiveView()
    view.CameraFocalPoint = [0, 0, 0]
    view.CameraViewUp = [0, 1, 0]
    view.CameraPosition = [0, 0, 40]
    view.CenterOfRotation = [0, 0, 0]
    smp.Render(view)


def resetCameraToForwardView(view=None):

    view = view or smp.GetActiveView()
    view.CameraFocalPoint = [0,0,0]
    view.CameraViewUp = [0, 0.27, 0.96]
    view.CameraPosition = [0, -72, 18.0]
    view.CenterOfRotation = [0, 0, 0]
    smp.Render(view)


def saveScreenshot(filename):
    smp.WriteImage(filename)

    # reload the saved screenshot as a pixmap
    screenshot = QtGui.QPixmap()
    screenshot.load(filename)

    # create a new pixmap with the status bar widget painted at the bottom
    statusBar = QtGui.QPixmap.grabWidget(getMainWindow().statusBar())
    composite = QtGui.QPixmap(screenshot.width(), screenshot.height() + statusBar.height())
    painter = QtGui.QPainter()
    painter.begin(composite)
    painter.drawPixmap(screenshot.rect(), screenshot, screenshot.rect())
    painter.drawPixmap(statusBar.rect().translated(0, screenshot.height()), statusBar, statusBar.rect())
    painter.end()

    # save final screenshot
    composite.save(filename)


def getSpreadSheetViewProxy():
    for p in smp.servermanager.ProxyManager():
        if p.GetXMLName() == 'SpreadSheetView':
            return p


def clearSpreadSheetView():
    view = getSpreadSheetViewProxy()
    view.Representations = []


def showSourceInSpreadSheet(source):

    spreadSheetView = getSpreadSheetViewProxy()
    smp.Show(source, spreadSheetView)

    # Work around a bug where the 'Showing' combobox doesn't update.
    # Calling hide and show again will trigger the refresh.
    smp.Hide(source, spreadSheetView)
    smp.Show(source, spreadSheetView)


def createGrid(view=None):

    view = view or smp.GetActiveView()
    grid = smp.RSlidar16GridSource(guiName='Measurement Grid')
    rep = smp.Show(grid, view)
    rep.DiffuseColor = [0.2, 0.2, 0.2]
    rep.Pickable = 0
    rep.Visibility = 0
    smp.SetActiveSource(None)
    return grid


def hideGrid():
    smp.GetDisplayProperties(app.grid).Hide()


def showGrid():
    smp.GetDisplayProperties(app.grid).Show()


def getAnimationScene():
    '''This function is a workaround because paraview.simple.GetAnimationScene()
    has an issue where the returned proxy might not have its Cues property initialized'''
    for proxy in servermanager.ProxyManager().GetProxiesInGroup("animation").values():
        if proxy.GetXMLName() == 'AnimationScene' and len(proxy.Cues):
            return proxy


def start():

    global app
    app = AppLogic()
    app.scene = getAnimationScene()

    view = smp.GetActiveView()
    view.Background = [0.0, 0.0, 0.0]
    view.Background2 = [0.0, 0.0, 0.2]
    view.UseGradientBackground = True
    smp._DisableFirstRenderCameraReset()
    smp.GetActiveView().LODThreshold = 1e100
    app.grid = createGrid()
    app.ruler = createRuler()

    resetCameraToForwardView()

    setupActions()
    disablePlaybackActions()
    disableSaveActions()
    app.actions['actionMeasure'].setEnabled(view.CameraParallelProjection)
    setupStatusBar()
    setupTimeSliderWidget()
    hideColorByComponent()
    #restoreNativeFileDialogsAction()
    updateRecentFiles()
    getTimeKeeper().connect('timeChanged()', onTimeChanged)

    initLidar()

def findQObjectByName(widgets, name):
    for w in widgets:
        if w.objectName == name:
            return w


def getMainWindow():
    return findQObjectByName(QtGui.QApplication.topLevelWidgets(), 'vvMainWindow')


def getPVApplicationCore():
    return PythonQt.paraview.pqPVApplicationCore.instance()


def getPVSettings():
    return getPVApplicationCore().settings()


def getTimeKeeper():
    return getPVApplicationCore().getActiveServer().getTimeKeeper()


def getPlaybackToolBar():
    return findQObjectByName(getMainWindow().children(), 'playbackToolbar')

def addShortcuts(keySequenceStr, function):
    shortcut = PythonQt.QtGui.QShortcut(PythonQt.QtGui.QKeySequence(keySequenceStr), getMainWindow())
    shortcut.connect("activated()", function)

def onTrailingFramesChanged(numFrames):
    app.numberOfTrailingFrames = numFrames
    if getReader():
        try:
            app.reader.NumberOfTrailingFrames = numFrames
            smp.Render()
            smp.Render(getSpreadSheetViewProxy())
        except AttributeError:
            pass

def setupTimeSliderWidget():

    frame = QtGui.QWidget()
    layout = QtGui.QHBoxLayout(frame)
    spinBox = QtGui.QSpinBox()
    spinBox.setMinimum(0)
    spinBox.setMaximum(100)
    spinBox.setValue(0)
    slider = QtGui.QSlider(QtCore.Qt.Horizontal)
    slider.setMaximumWidth(160)
    slider.connect('valueChanged(int)', onTimeSliderChanged)
    spinBox.connect('valueChanged(int)', onTimeSliderChanged)
    slider.setEnabled(False)
    spinBox.setEnabled(False)
    layout.addWidget(slider)
    layout.addWidget(spinBox)
    layout.addStretch()

    toolbar = getPlaybackToolBar()
    toolbar.addWidget(frame)
    app.timeSlider = slider
    app.timeSpinBox = spinBox


def updateSliderTimeRange():

    frame = int(app.scene.AnimationTime)
    lastFrame = int(app.scene.EndTime)

    for widget in (app.timeSlider, app.timeSpinBox):
        widget.setMinimum(0)
        widget.setMaximum(lastFrame)
        widget.setSingleStep(1)
        if hasattr(widget, 'setPageStep'):
            widget.setPageStep(10)
        widget.setValue(frame)
        widget.setEnabled(getNumberOfTimesteps())


def scheduleRender():
    if not app.renderIsPending:
        app.renderIsPending = True
        app.renderTimer.start(33)


def forceRender():
    smp.Render()
    app.renderIsPending = False


def onTimeSliderChanged(frame):
    app.scene.AnimationTime = frame
    updatePosition()


def setupStatusBar():

    statusBar = getMainWindow().statusBar()
    statusBar.addPermanentWidget(app.logoLabel)
    statusBar.addWidget(app.lidarTypeLabel)
    statusBar.addWidget(app.filenameLabel)
    statusBar.addWidget(app.timeLabel)
    statusBar.addWidget(app.localTime)
    statusBar.addWidget(app.framerate)
    statusBar.addWidget(app.tempLabel)
    statusBar.addWidget(app.statusLabel)

def setActionIcon(actionName, iconPath):
    app.actions[actionName].setIcon(QtGui.QIcon(QtGui.QPixmap(iconPath)))


def onTimeChanged():

    frame = int(getTimeKeeper().getTime())
    app.timeLabel.setText('  Frame: %s' % frame)

    if app.zhenlv == 1:
        app.zhenlv_jishu = frame
    elif app.zhenlv == 11:
        app.zhenlv = 0
        app.zhenlv_cur = frame - app.zhenlv_jishu
    app.zhenlv = app.zhenlv + 1

    reader = getReader()
    sensor = getSensor()
    if reader:
        curTime = str(reader.GetClientSideObject().GetPktCurrentTime())
        app.localTime.setText('  Timestamp: %s ' % curTime)
        cur_framerate = reader.GetClientSideObject().return_frame_rate_now()
        app.framerate.setText('  Framerate: %d ' % cur_framerate)
    elif sensor:
        curTime = str(sensor.GetClientSideObject().GetPktCurrentTime())
        app.localTime.setText('  Timestamp: %s ' % curTime)
        cur_framerate = sensor.GetClientSideObject().return_frame_rate_now()
        app.framerate.setText('  Framerate: %d ' % cur_framerate)

    for widget in (app.timeSlider, app.timeSpinBox):
        widget.blockSignals(True)
        widget.setValue(frame)
        widget.blockSignals(False)


def onGridProperties():
    if gridAdjustmentDialog.showDialog(getMainWindow(), app.grid):
        smp.Render()

def initLidar():

    dialog = vvCalibrationDialog(getMainWindow())

    lidarTypeName = dialog.GetSensorTypeName()
    laserNum = dialog.GetLaserNum()

    app.lidarTypeLabel.setText('Lidar Type: %s' % lidarTypeName)

    dialog = vvLaserSelectionDialog(getMainWindow())
    dialog.reset(laserNum)

    dialog = vvPointsSelectionDialog(getMainWindow())
    dialog.unselected()

    dialog = vvCropReturnsDialog(getMainWindow())
    dialog.reset()

def onLaserSelection(show = True):

    reader = getReader()
    sensor = getSensor()

    angles = ""
    if reader:
        angles = reader.GetClientSideObject().GetAngles()
    elif sensor:
        angles = sensor.GetClientSideObject().GetAngles()

    dialog = vvLaserSelectionDialog(getMainWindow())
    dialog.setup(angles)
    if not dialog.exec_():
        return None

    laserSelected = dialog.getLaserSelection()

    if reader:
        reader.GetClientSideObject().SetLaserSelection(laserSelected)
    elif sensor:
        sensor.GetClientSideObject().SetLaserSelection(laserSelected)

def onPointsSelection(show = True):

    reader = getReader()
    sensor = getSensor()

    dialog = vvPointsSelectionDialog(getMainWindow())
    if not dialog.exec_():
        return None

    pointsSelection = dialog.getPointsSelection()

    if reader:
        reader.GetClientSideObject().SetPointsRange(pointsSelection)
    elif sensor:
        sensor.GetClientSideObject().SetPointsRange(pointsSelection)


def onShowInformation(Show = True):
  
    dialog = vvConnectInformationDialog(getMainWindow())

    ssn = ""
    mac = ""
    topVersion = ""
    bottomVersion = ""
    reader = getReader()
    sensor = getSensor()
    if reader:
        ssn = reader.GetClientSideObject().GetSSN()
        mac = reader.GetClientSideObject().GetMAC()
        topVersion = reader.GetClientSideObject().GetTopVersion()
        bottomVersion = reader.GetClientSideObject().GetBottomVersion()
    elif sensor:
        ssn = sensor.GetClientSideObject().GetSSN()
        mac = sensor.GetClientSideObject().GetMAC()
        topVersion = sensor.GetClientSideObject().GetTopVersion()
        bottomVersion = sensor.GetClientSideObject().GetBottomVersion()

    dialog.setSSN(ssn)
    dialog.setMAC(mac)
    dialog.setTopVersion(topVersion)
    dialog.setBottomVersion(bottomVersion)
    dialog.updateUI()
    dialog.exec_()

def onNetworkConfigSensor(Show = True):    
    networkConfigSensor(True)
    
def networkConfigSensor(force):

    dialog = vvNetworkConfigSensorDialog(getMainWindow())
    if force == False and not dialog.GetShowDialog():
        return True

    if not dialog.exec_():
        return False

    return True

def onNetworkConfigPcap(Show = True):    
    networkConfigPcap(True)
    
def networkConfigPcap(force):

    dialog = vvNetworkConfigPcapDialog(getMainWindow())
    if force == False and not dialog.GetShowDialog():
        return True

    if not dialog.exec_():
        return False

    return True

def hideColorByComponent():
    getMainWindow().findChild('vvColorToolbar').findChild('pqDisplayColorWidget').findChildren('QComboBox')[1].hide()

def addRecentFile(filename):

    recentFiles = getRecentFiles()

    try:
        recentFiles.remove(filename)
    except ValueError:
        pass

    recentFiles = recentFiles[:4]
    recentFiles.insert(0, filename)
    getPVSettings().setValue('RSlidar16Plugin/RecentFiles', recentFiles)
    updateRecentFiles()


def openRecentFile(filename):
    if not os.path.isfile(filename):
        QtGui.QMessageBox.warning(getMainWindow(), 'File not found', 'File not found: %s' % filename)
        return

    if os.path.splitext(filename)[1].lower() == '.pcap':
        openPCAP(filename)
    else:
        openData(filename)


def getRecentFiles():
    return list(getPVSettings().value('RSlidar16Plugin/RecentFiles', []) or [])


def updateRecentFiles():
    settings = getPVSettings()
    recentFiles = getRecentFiles()
    recentFilesMenu = findQObjectByName(findQObjectByName(getMainWindow().menuBar().children(), 'menu_File').children(), 'menuRecent_Files')

    clearMenuAction = app.actions['actionClear_Menu']
    for action in recentFilesMenu.actions()[:-2]:
        recentFilesMenu.removeAction(action)

    def createActionFunction(filename):
        def f():
            openRecentFile(filename)
        return f

    actions = []
    for filename in recentFiles:
        actions.append(QtGui.QAction(os.path.basename(filename), recentFilesMenu))
        actions[-1].connect('triggered()', createActionFunction(filename))
    recentFilesMenu.insertActions(recentFilesMenu.actions()[0], actions)


def onClearMenu():
    settings = getPVSettings()
    settings.setValue('RSlidar16Plugin/RecentFiles', [])
    updateRecentFiles()

def toggleProjectionType():

    view = smp.GetActiveView()

    view.CameraParallelProjection = not view.CameraParallelProjection
    if app.actions['actionMeasure'].isChecked():
        app.actions['actionMeasure'].trigger()
        app.actions['actionMeasure'].toggle()

    app.actions['actionMeasure'].setEnabled(view.CameraParallelProjection)

    smp.Render()

def setViewTo(axis,sign):
    view = smp.GetActiveView()
    viewUp = view.CameraViewUp
    position = view.CameraPosition

    norm = math.sqrt(math.pow(position[0],2) + math.pow(position[1],2) + math.pow(position[2],2))

    if axis == 'X':
        view.CameraViewUp = [0,0,1]
        view.CameraPosition = [-1*sign*norm,0,0]
    elif axis == 'Y':
        view.CameraViewUp = [0,0,1]
        view.CameraPosition = [0,-1*sign*norm,0]
    elif axis == 'Z':
        view.CameraViewUp = [0,1,0]
        view.CameraPosition = [0,0,-1*sign*norm]

    view.CameraFocalPoint = [0,0,0]
    view.CenterOfRotation = [0,0,0]

    view.ResetCamera()
    smp.Render()


def setViewToXPlus():
    setViewTo('X',1)


def setViewToXMinus():
    setViewTo('X',-1)


def setViewToYPlus():
    setViewTo('Y',1)


def setViewToYMinus():
    setViewTo('Y',-1)


def setViewToZPlus():
    setViewTo('Z',1)


def setViewToZMinus():
    setViewTo('Z',-1)

def setFilterToDual():
    setFilterTo(0)

def setFilterToDistanceNear():
    setFilterTo(vtkRSlidar16Reader.DUAL_DISTANCE_NEAR)

def setFilterToDistanceFar():
    setFilterTo(vtkRSlidar16Reader.DUAL_DISTANCE_FAR)

def setFilterToIntensityHigh():
    setFilterTo(vtkRSlidar16Reader.DUAL_INTENSITY_HIGH)

def setFilterToIntensityLow():
    setFilterTo(vtkRSlidar16Reader.DUAL_INTENSITY_LOW)

def setFilterTo(mask):
    reader = getReader()
    if reader:
        reader.DualReturnFilter = mask
        smp.Render()
        smp.Render(getSpreadSheetViewProxy())

    sensor = getSensor()
    if sensor:
        sensor.DualReturnFilter = mask
        smp.Render()
        smp.Render(getSpreadSheetViewProxy())

def transformMode():
    reader = getReader()
    if not reader:
        return None

    if reader.ApplyTransform:
        if app.relativeTransform:
            return 2 # relative
        else:
            return 1 # absolute
    return 0 # raw

def setTransformMode(mode):
    # 0 - raw
    # 1 - absolute
    # 2 - relative
    reader = getReader()

    if reader:
        reader.ApplyTransform = (mode > 0)
    app.transformMode = mode
    app.relativeTransform = (mode == 2)

def setupActions():

    mW = getMainWindow()
    actions = mW.findChildren('QAction')

    app.actions = {}

    for a in actions:
        app.actions[a.objectName] = a

    # File
    app.actions['actionChoose_Calibration_File'].connect('triggered()', onChooseCalibrationFile)
    app.actions['actionNetworkConfigSensor'].connect('triggered()', onNetworkConfigSensor)
    app.actions['actionNetworkConfigPcap'].connect('triggered()', onNetworkConfigPcap)
    app.actions['actionSavePCAP'].connect('triggered()', onSavePCAP)
    app.actions['actionSaveLAS'].connect('triggered()', onSaveLAS)
    app.actions['actionSaveCSV'].connect('triggered()', onSaveCSV)
    app.actions['actionSavePCD'].connect('triggered()', onSavePCD)
    app.actions['actionSaveScreenshot'].connect('triggered()', onSaveScreenshot)
    app.actions['actionClose'].connect('triggered()', close)
    app.actions['actionClear_Menu'].connect('triggered()', onClearMenu)

    # View
    app.actions['actionLaserSelection'].connect('triggered()', onLaserSelection)
    app.actions['actionPointsSelection'].connect('triggered()', onPointsSelection)
    app.actions['actionCropReturns'].connect('triggered()', onCropReturns)
    app.actions['actionGrid_Properties'].connect('triggered()', onGridProperties)

    app.actions['actionReset_Camera'].connect('triggered()', resetCamera)
    app.actions['actionPlaneFit'].connect('triggered()', planeFit)
    app.actions['actionToggleProjection'].connect('triggered()', toggleProjectionType)
    app.actions['actionMeasure'].connect('triggered()', toggleRulerContext)

    app.actions['actionSetViewXPlus'].connect('triggered()', setViewToXPlus)
    app.actions['actionSetViewXMinus'].connect('triggered()', setViewToXMinus)
    app.actions['actionSetViewYPlus'].connect('triggered()', setViewToYPlus)
    app.actions['actionSetViewYMinus'].connect('triggered()', setViewToYMinus)
    app.actions['actionSetViewZPlus'].connect('triggered()', setViewToZPlus)
    app.actions['actionSetViewZMinus'].connect('triggered()', setViewToZMinus)

    # Tools
    app.actions['actionGo_To_Start'].connect('triggered()', gotoStart)
    app.actions['actionSeek_Backward'].connect('triggered()', seekBackward)
    app.actions['actionPlay'].connect('triggered()', togglePlay)
    app.actions['actionSeek_Forward'].connect('triggered()', seekForward)
    app.actions['actionGo_To_End'].connect('triggered()', gotoEnd)
    app.actions['actionRecord'].connect('triggered()', onRecord)

    app.actions['actionLidar_Information'].connect('triggered()', onShowInformation)

    # About
    app.actions['actionAbout_RSView'].connect('triggered()', onAbout)
    app.actions['actionRSView_License_Info'].connect('triggered()', onLicenseInfo)
    app.actions['actionRSViewUserGuide'].connect('triggered()', onUserGuide)

    #
    # playback toolbar
    #
    playbackToolbar = mW.findChild('QToolBar','playbackToolbar')

    # seek
    buttons = {}
    for button in playbackToolbar.findChildren('QToolButton'):
        buttons[button.text] = button

    buttons['Seek Forward'].connect('pressed()', seekForwardPressed)
    buttons['Seek Forward'].connect('released()', seekForwardReleased)
    buttons['Seek Backward'].connect('pressed()', seekBackwardPressed)
    buttons['Seek Backward'].connect('released()', seekBackwardReleased)

    #
    # color toolbar
    #
    colorToolbar = mW.findChild('QToolBar','colorToolBar')

    # point size
    pointsSizeLabel = QtGui.QLabel('  PZ: ')
    colorToolbar.addWidget(pointsSizeLabel)

    pointsSizeBox = QtGui.QSpinBox()
    pointsSizeBox.toolTip = "Point Size"
    pointsSizeBox.setMinimum(1)
    pointsSizeBox.setMaximum(10)
    pointsSizeBox.setValue(2)
    pointsSizeBox.connect('valueChanged(int)', onPointsSizeChanged)
    app.pointsSizeSpinBox = pointsSizeBox

    app.actions['actionPointsSizeSelector'] = colorToolbar.addWidget(pointsSizeBox)
    app.actions['actionPointsSizeSelector'].setVisible(True)

    #
    # cloud toolbar
    #
    cloudToolBar = mW.findChild('QToolBar','cloudToolBar')

    # trailing frames
    spinBoxLabel = QtGui.QLabel('  TF: ')
    spinBoxLabel.toolTip = "Number of trailing frames"
    cloudToolBar.addWidget(spinBoxLabel)

    spinBox = QtGui.QSpinBox()
    spinBox.toolTip = "Number of trailing frames"
    spinBox.setMinimum(0)
    spinBox.setMaximum(100)
    spinBox.connect('valueChanged(int)', onTrailingFramesChanged)
    app.trailingFramesSpinBox = spinBox

    app.actions['actionTrailingFramesSelector'] = cloudToolBar.addWidget(spinBox)
    app.actions['actionTrailingFramesSelector'].setVisible(True)

